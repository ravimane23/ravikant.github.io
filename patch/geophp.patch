diff --git a/geoPHP/geoPHP.inc b/geoPHP/geoPHP.inc
index 04c9184..0803e86 100755
--- a/geoPHP/geoPHP.inc
+++ b/geoPHP/geoPHP.inc
@@ -1,299 +1,336 @@
-<?php
-/*
- * (c) Patrick Hayes
- *
- * This code is open-source and licenced under the Modified BSD License.
- * For the full copyright and license information, please view the LICENSE
- * file that was distributed with this source code.
- */
-
-// Adapters
-include_once("lib/adapters/GeoAdapter.class.php"); // Abtract class
-include_once("lib/adapters/GeoJSON.class.php");
-include_once("lib/adapters/WKT.class.php");
-include_once("lib/adapters/EWKT.class.php");
-include_once("lib/adapters/WKB.class.php");
-include_once("lib/adapters/EWKB.class.php");
-include_once("lib/adapters/KML.class.php");
-include_once("lib/adapters/GPX.class.php");
-include_once("lib/adapters/GeoRSS.class.php");
-include_once("lib/adapters/GoogleGeocode.class.php");
-include_once("lib/adapters/GeoHash.class.php");
-
-// Geometries
-include_once("lib/geometry/Geometry.class.php"); // Abtract class
-include_once("lib/geometry/Point.class.php");
-include_once("lib/geometry/Collection.class.php"); // Abtract class
-include_once("lib/geometry/LineString.class.php");
-include_once("lib/geometry/MultiPoint.class.php");
-include_once("lib/geometry/Polygon.class.php");
-include_once("lib/geometry/MultiLineString.class.php");
-include_once("lib/geometry/MultiPolygon.class.php");
-include_once("lib/geometry/GeometryCollection.class.php");
-
-class geoPHP
-{
-
-  static function version() {
-    return '1.1';
-  }
-
-  // geoPHP::load($data, $type, $other_args);
-  // if $data is an array, all passed in values will be combined into a single geometry
-  static function load() {
-    $args = func_get_args();
-
-    $data = array_shift($args);
-    $type = array_shift($args);
-
-    $type_map = geoPHP::getAdapterMap();
-
-    // Auto-detect type if needed
-    if (!$type) {
-      // If the user is trying to load a Geometry from a Geometry... Just pass it back
-      if (is_object($data)) {
-        if ($data instanceOf Geometry) return $data;
-      }
-      
-      $detected = geoPHP::detectFormat($data);
-      if (!$detected) {
-        return FALSE;
-      }
-      
-      $format = explode(':', $detected);
-      $type = array_shift($format);
-      $args = $format;
-    }
-
-    $processor_type = $type_map[$type];
-
-    if (!$processor_type) {
-      throw new exception('geoPHP could not find an adapter of type '.htmlentities($type));
-      exit;
-    }
-
-    $processor = new $processor_type();
-
-    // Data is not an array, just pass it normally
-    if (!is_array($data)) {
-      $result = call_user_func_array(array($processor, "read"), array_merge(array($data), $args));
-    }
-    // Data is an array, combine all passed in items into a single geomtetry
-    else {
-      $geoms = array();
-      foreach ($data as $item) {
-        $geoms[] = call_user_func_array(array($processor, "read"), array_merge(array($item), $args));
-      }
-      $result = geoPHP::geometryReduce($geoms);
-    }
-
-    return $result;
-  }
-
-  static function getAdapterMap() {
-    return array (
-      'wkt' =>  'WKT',
-      'ewkt' => 'EWKT',
-      'wkb' =>  'WKB',
-      'ewkb' => 'EWKB',
-      'json' => 'GeoJSON',
-      'kml' =>  'KML',
-      'gpx' =>  'GPX',
-      'georss' => 'GeoRSS',
-      'google_geocode' => 'GoogleGeocode',
-      'geohash' => 'GeoHash',
-    );
-  }
-
-  static function geometryList() {
-    return array(
-      'point' => 'Point',
-      'linestring' => 'LineString',
-      'polygon' => 'Polygon',
-      'multipoint' => 'MultiPoint',
-      'multilinestring' => 'MultiLineString',
-      'multipolygon' => 'MultiPolygon',
-      'geometrycollection' => 'GeometryCollection',
-    );
-  }
-
-  static function geosInstalled($force = NULL) {
-    static $geos_installed = NULL;
-    if ($force !== NULL) $geos_installed = $force;
-    if ($geos_installed !== NULL) {
-      return $geos_installed;
-    }
-    $geos_installed = class_exists('GEOSGeometry');
-    return $geos_installed;
-  }
-
-  static function geosToGeometry($geos) {
-    if (!geoPHP::geosInstalled()) {
-      return NULL;
-    }
-    $wkb_writer = new GEOSWKBWriter();
-    $wkb = $wkb_writer->writeHEX($geos);
-    $geometry = geoPHP::load($wkb, 'wkb', TRUE);
-    if ($geometry) {
-      $geometry->setGeos($geos);
-      return $geometry;
-    }
-  }
-
-  // Reduce a geometry, or an array of geometries, into their 'lowest' available common geometry.
-  // For example a GeometryCollection of only points will become a MultiPoint
-  // A multi-point containing a single point will return a point.
-  // An array of geometries can be passed and they will be compiled into a single geometry
-  static function geometryReduce($geometry) {
-    // If it's an array of one, then just parse the one
-    if (is_array($geometry)) {
-      if (empty($geometry)) return FALSE;
-      if (count($geometry) == 1) return geoPHP::geometryReduce($geometry[0]);
-    }
-
-    // If the geometry cannot even theoretically be reduced more, then pass it back
-    if (gettype($geometry) == 'object') {
-      $passbacks = array('Point','LineString','Polygon');
-      if (in_array($geometry->geometryType(),$passbacks)) {
-        return $geometry;
-      }
-    }
-
-    // If it is a mutlti-geometry, check to see if it just has one member
-    // If it does, then pass the member, if not, then just pass back the geometry
-    if (gettype($geometry) == 'object') {
-      $simple_collections = array('MultiPoint','MultiLineString','MultiPolygon');
-      if (in_array(get_class($geometry),$passbacks)) {
-        $components = $geometry->getComponents();
-        if (count($components) == 1) {
-          return $components[0];
-        }
-        else {
-          return $geometry;
-        }
-      }
-    }
-
-    // So now we either have an array of geometries, a GeometryCollection, or an array of GeometryCollections
-    if (!is_array($geometry)) {
-      $geometry = array($geometry);
-    }
-
-    $geometries = array();
-    $geom_types = array();
-
-    $collections = array('MultiPoint','MultiLineString','MultiPolygon','GeometryCollection');
-
-    foreach ($geometry as $item) {
-      if ($item) {
-        if (in_array(get_class($item), $collections)) {
-          foreach ($item->getComponents() as $component) {
-            $geometries[] = $component;
-            $geom_types[] = $component->geometryType();
-          }
-        }
-        else {
-          $geometries[] = $item;
-          $geom_types[] = $item->geometryType();
-        }
-      }
-    }
-
-    $geom_types = array_unique($geom_types);
-    
-    if (empty($geom_types)) {
-      return FALSE;
-    }
-
-    if (count($geom_types) == 1) {
-      if (count($geometries) == 1) {
-        return $geometries[0];
-      }
-      else {
-        $class = 'Multi'.$geom_types[0];
-        return new $class($geometries);
-      }
-    }
-    else {
-      return new GeometryCollection($geometries);
-    }
-  }
-
-  // Detect a format given a value. This function is meant to be SPEEDY.
-  // It could make a mistake in XML detection if you are mixing or using namespaces in weird ways (ie, KML inside an RSS feed)
-  static function detectFormat(&$input) {
-    $mem = fopen('php://memory', 'r+');
-    fwrite($mem, $input, 11); // Write 11 bytes - we can detect the vast majority of formats in the first 11 bytes
-    fseek($mem, 0);
-
-    $bytes = unpack("c*", fread($mem, 11));
-
-    // If bytes is empty, then we were passed empty input
-    if (empty($bytes)) return FALSE;
-
-    // First char is a tab, space or carriage-return. trim it and try again
-    if ($bytes[1] == 9 || $bytes[1] == 10 || $bytes[1] == 32) {
-      return geoPHP::detectFormat(ltrim($input));
-    }
-
-    // Detect WKB or EWKB -- first byte is 1 (little endian indicator)
-    if ($bytes[1] == 1) {
-      // If SRID byte is TRUE (1), it's EWKB
-      if ($bytes[5]) return 'ewkb';
-      else return 'wkb';
-    }
-
-    // Detect HEX encoded WKB or EWKB (PostGIS format) -- first byte is 48, second byte is 49 (hex '01' => first-byte = 1)
-    if ($bytes[1] == 48 && $bytes[2] == 49) {
-      // The shortest possible WKB string (LINESTRING EMPTY) is 18 hex-chars (9 encoded bytes) long
-      // This differentiates it from a geohash, which is always shorter than 18 characters.
-      if (strlen($input) >= 18) {
-        //@@TODO: Differentiate between EWKB and WKB -- check hex-char 10 or 11 (SRID bool indicator at encoded byte 5)
-        return 'ewkb:1';
-      }
-    }
-
-    // Detect GeoJSON - first char starts with {
-    if ($bytes[1] == 123) {
-      return 'json';
-    }
-
-    // Detect EWKT - first char is S
-    if ($bytes[1] == 83) {
-      return 'ewkt';
-    }
-
-    // Detect WKT - first char starts with P (80), L (76), M (77), or G (71)
-    $wkt_chars = array(80, 76, 77, 71);
-    if (in_array($bytes[1], $wkt_chars)) {
-      return 'wkt';
-    }
-
-    // Detect XML -- first char is <
-    if ($bytes[1] == 60) {
-      // grab the first 256 characters
-      $string = substr($input, 0, 256);
-      if (strpos($string, '<kml') !== FALSE)        return 'kml';
-      if (strpos($string, '<coordinate') !== FALSE) return 'kml';
-      if (strpos($string, '<gpx') !== FALSE)        return 'gpx';
-      if (strpos($string, '<georss') !== FALSE)     return 'georss';
-      if (strpos($string, '<rss') !== FALSE)        return 'georss';
-      if (strpos($string, '<feed') !== FALSE)       return 'georss';
-    }
-
-    // We need an 8 byte string for geohash and unpacked WKB / WKT
-    fseek($mem, 0);
-    $string = trim(fread($mem, 8));
-
-    // Detect geohash - geohash ONLY contains lowercase chars and numerics
-    preg_match('/[a-z0-9]+/', $string, $matches);
-    if ($matches[0] == $string) {
-      return 'geohash';
-    }
-
-    // What do you get when you cross an elephant with a rhino?
-    // http://youtu.be/RCBn5J83Poc
-    return FALSE;
-  }
-
-}
+<?php
+
+/*
+ * (c) Patrick Hayes
+ *
+ * This code is open-source and licenced under the Modified BSD License.
+ * For the full copyright and license information, please view the LICENSE
+ * file that was distributed with this source code.
+ */
+
+// Adapters.
+// Abtract class.
+include_once "lib/adapters/GeoAdapter.class.php";
+include_once "lib/adapters/GeoJSON.class.php";
+include_once "lib/adapters/WKT.class.php";
+include_once "lib/adapters/EWKT.class.php";
+include_once "lib/adapters/WKB.class.php";
+include_once "lib/adapters/EWKB.class.php";
+include_once "lib/adapters/KML.class.php";
+include_once "lib/adapters/GPX.class.php";
+include_once "lib/adapters/GeoRSS.class.php";
+include_once "lib/adapters/GoogleGeocode.class.php";
+include_once "lib/adapters/GeoHash.class.php";
+
+// Geometries.
+// Abtract class.
+include_once "lib/geometry/Geometry.class.php";
+include_once "lib/geometry/Point.class.php";
+// Abtract class.
+include_once "lib/geometry/Collection.class.php";
+include_once "lib/geometry/LineString.class.php";
+include_once "lib/geometry/MultiPoint.class.php";
+include_once "lib/geometry/Polygon.class.php";
+include_once "lib/geometry/MultiLineString.class.php";
+include_once "lib/geometry/MultiPolygon.class.php";
+include_once "lib/geometry/GeometryCollection.class.php";
+/**
+ * .
+ */
+class geoPHP {
+
+  /**
+   * .
+   */
+  public static function version() {
+    return '1.1';
+  }
+
+  // geoPHP::load($data, $type, $other_args);.
+
+  /**
+   * If $data is an array, all passed in values will be combined into a single geometry.
+   */
+  public static function load() {
+    $args = func_get_args();
+
+    $data = array_shift($args);
+    $type = array_shift($args);
+
+    $type_map = geoPHP::getAdapterMap();
+
+    // Auto-detect type if needed.
+    if (!$type) {
+      // If the user is trying to load a Geometry from a Geometry... Just pass it back.
+      if (is_object($data)) {
+        if ($data instanceof Geometry) {
+          return $data;
+        }
+      }
+
+      $detected = geoPHP::detectFormat($data);
+      if (!$detected) {
+        return FALSE;
+      }
+
+      $format = explode(':', $detected);
+      $type = array_shift($format);
+      $args = $format;
+    }
+
+    $processor_type = $type_map[$type];
+
+    if (!$processor_type) {
+      throw new exception('geoPHP could not find an adapter of type ' . htmlentities($type));
+      exit;
+    }
+
+    $processor = new $processor_type();
+
+    // Data is not an array, just pass it normally.
+    if (!is_array($data)) {
+      $result = call_user_func_array([$processor, "read"], array_merge([$data], $args));
+    }
+    // Data is an array, combine all passed in items into a single geomtetry.
+    else {
+      $geoms = [];
+      foreach ($data as $item) {
+        $geoms[] = call_user_func_array([$processor, "read"], array_merge([$item], $args));
+      }
+      $result = geoPHP::geometryReduce($geoms);
+    }
+
+    return $result;
+  }
+
+  /**
+   * .
+   */
+  public static function getAdapterMap() {
+    return ['wkt' => 'WKT', 'ewkt' => 'EWKT', 'wkb' => 'WKB', 'ewkb' => 'EWKB', 'json' => 'GeoJSON', 'kml' => 'KML', 'gpx' => 'GPX', 'georss' => 'GeoRSS', 'google_geocode' => 'GoogleGeocode', 'geohash' => 'GeoHash'];
+  }
+
+  /**
+   * .
+   */
+  public static function geometryList() {
+    return ['point' => 'Point', 'linestring' => 'LineString', 'polygon' => 'Polygon', 'multipoint' => 'MultiPoint', 'multilinestring' => 'MultiLineString', 'multipolygon' => 'MultiPolygon', 'geometrycollection' => 'GeometryCollection'];
+  }
+
+  /**
+   * .
+   */
+  public static function geosInstalled($force = NULL) {
+    static $geos_installed = NULL;
+    if ($force !== NULL) {
+      $geos_installed = $force;
+    }
+    if ($geos_installed !== NULL) {
+      return $geos_installed;
+    }
+    $geos_installed = class_exists('GEOSGeometry');
+    return $geos_installed;
+  }
+
+  /**
+   * .
+   */
+  public static function geosToGeometry($geos) {
+    if (!geoPHP::geosInstalled()) {
+      return NULL;
+    }
+    $wkb_writer = new GEOSWKBWriter();
+    $wkb = $wkb_writer->writeHEX($geos);
+    $geometry = geoPHP::load($wkb, 'wkb', TRUE);
+    if ($geometry) {
+      $geometry->setGeos($geos);
+      return $geometry;
+    }
+  }
+
+  // Reduce a geometry, or an array of geometries, into their 'lowest' available common geometry.
+  // For example a GeometryCollection of only points will become a MultiPoint.
+  // A multi-point containing a single point will return a point.
+
+  /**
+   * An array of geometries can be passed and they will be compiled into a single geometry.
+   */
+  public static function geometryReduce($geometry) {
+    // If it's an array of one, then just parse the one.
+    if (is_array($geometry)) {
+      if (empty($geometry)) {
+        return FALSE;
+      }
+      if (count($geometry) == 1) {
+        return geoPHP::geometryReduce($geometry[0]);
+      }
+    }
+
+    // If the geometry cannot even theoretically be reduced more, then pass it back.
+    if (gettype($geometry) == 'object') {
+      $passbacks = ['Point', 'LineString', 'Polygon'];
+      if (in_array($geometry->geometryType(), $passbacks)) {
+        return $geometry;
+      }
+    }
+
+    // If it is a mutlti-geometry, check to see if it just has one member
+    // If it does, then pass the member, if not, then just pass back the geometry.
+    if (gettype($geometry) == 'object') {
+      $simple_collections = ['MultiPoint', 'MultiLineString', 'MultiPolygon'];
+      if (in_array(get_class($geometry), $passbacks)) {
+        $components = $geometry->getComponents();
+        if (count($components) == 1) {
+          return $components[0];
+        }
+        else {
+          return $geometry;
+        }
+      }
+    }
+
+    // So now we either have an array of geometries, a GeometryCollection, or an array of GeometryCollections.
+    if (!is_array($geometry)) {
+      $geometry = [$geometry];
+    }
+
+    $geometries = [];
+    $geom_types = [];
+
+    $collections = ['MultiPoint', 'MultiLineString', 'MultiPolygon', 'GeometryCollection'];
+
+    foreach ($geometry as $item) {
+      if ($item) {
+        if (in_array(get_class($item), $collections)) {
+          foreach ($item->getComponents() as $component) {
+            $geometries[] = $component;
+            $geom_types[] = $component->geometryType();
+          }
+        }
+        else {
+          $geometries[] = $item;
+          $geom_types[] = $item->geometryType();
+        }
+      }
+    }
+
+    $geom_types = array_unique($geom_types);
+
+    if (empty($geom_types)) {
+      return FALSE;
+    }
+
+    if (count($geom_types) == 1) {
+      if (count($geometries) == 1) {
+        return $geometries[0];
+      }
+      else {
+        $class = 'Multi' . $geom_types[0];
+        return new $class($geometries);
+      }
+    }
+    else {
+      return new GeometryCollection($geometries);
+    }
+  }
+
+  // Detect a format given a value. This function is meant to be SPEEDY.
+
+  /**
+   * It could make a mistake in XML detection if you are mixing or using namespaces in weird ways (ie, KML inside an RSS feed)
+   */
+  public static function detectFormat(&$input) {
+    $mem = fopen('php://memory', 'r+');
+    // Write 11 bytes - we can detect the vast majority of formats in the first 11 bytes.
+    fwrite($mem, $input, 11);
+    fseek($mem, 0);
+
+    $bytes = unpack("c*", fread($mem, 11));
+
+    // If bytes is empty, then we were passed empty input.
+    if (empty($bytes)) {
+      return FALSE;
+    }
+
+    // First char is a tab, space or carriage-return. trim it and try again.
+    if ($bytes[1] == 9 || $bytes[1] == 10 || $bytes[1] == 32) {
+      return geoPHP::detectFormat(ltrim($input));
+    }
+
+    // Detect WKB or EWKB -- first byte is 1 (little endian indicator)
+    if ($bytes[1] == 1) {
+      // If SRID byte is TRUE (1), it's EWKB.
+      if ($bytes[5]) {
+        return 'ewkb';
+      }
+      else {
+        return 'wkb';
+      }
+    }
+
+    // Detect HEX encoded WKB or EWKB (PostGIS format) -- first byte is 48, second byte is 49 (hex '01' => first-byte = 1)
+    if ($bytes[1] == 48 && $bytes[2] == 49) {
+      // The shortest possible WKB string (LINESTRING EMPTY) is 18 hex-chars (9 encoded bytes) long.
+      // This differentiates it from a geohash, which is always shorter than 18 characters.
+      if (strlen($input) >= 18) {
+        // @@TODO: Differentiate between EWKB and WKB -- check hex-char 10 or 11 (SRID bool indicator at encoded byte 5)
+        return 'ewkb:1';
+      }
+    }
+
+    // Detect GeoJSON - first char starts with {.
+    if ($bytes[1] == 123) {
+      return 'json';
+    }
+
+    // Detect EWKT - first char is S.
+    if ($bytes[1] == 83) {
+      return 'ewkt';
+    }
+
+    // Detect WKT - first char starts with P (80), L (76), M (77), or G (71)
+    $wkt_chars = [80, 76, 77, 71];
+    if (in_array($bytes[1], $wkt_chars)) {
+      return 'wkt';
+    }
+
+    // Detect XML -- first char is <.
+    if ($bytes[1] == 60) {
+      // Grab the first 256 characters.
+      $string = substr($input, 0, 256);
+      if (strpos($string, '<kml') !== FALSE) {
+        return 'kml';
+      }
+      if (strpos($string, '<coordinate') !== FALSE) {
+        return 'kml';
+      }
+      if (strpos($string, '<gpx') !== FALSE) {
+        return 'gpx';
+      }
+      if (strpos($string, '<georss') !== FALSE) {
+        return 'georss';
+      }
+      if (strpos($string, '<rss') !== FALSE) {
+        return 'georss';
+      }
+      if (strpos($string, '<feed') !== FALSE) {
+        return 'georss';
+      }
+    }
+
+    // We need an 8 byte string for geohash and unpacked WKB / WKT.
+    fseek($mem, 0);
+    $string = trim(fread($mem, 8));
+
+    // Detect geohash - geohash ONLY contains lowercase chars and numerics.
+    preg_match('/[a-z0-9]+/', $string, $matches);
+    if ($matches[0] == $string) {
+      return 'geohash';
+    }
+
+    // What do you get when you cross an elephant with a rhino?
+    // http://youtu.be/RCBn5J83Poc
+    return FALSE;
+  }
+
+}
diff --git a/geoPHP/lib/adapters/EWKB.class.php b/geoPHP/lib/adapters/EWKB.class.php
index 0d324d3..b48d3b1 100755
--- a/geoPHP/lib/adapters/EWKB.class.php
+++ b/geoPHP/lib/adapters/EWKB.class.php
@@ -1,23 +1,24 @@
 <?php
+
 /**
- * EWKB (Extended Well Known Binary) Adapter
+ * EWKB (Extended Well Known Binary) Adapter.
  */
-class EWKB extends WKB
-{
-  
+class EWKB extends WKB {
+
   /**
-   * Read WKB binary string into geometry objects
+   * Read WKB binary string into geometry objects.
    *
-   * @param string $wkb An Extended-WKB binary string
+   * @param string $wkb
+   *   An Extended-WKB binary string.
    *
    * @return Geometry
    */
   public function read($wkb, $is_hex_string = FALSE) {
     if ($is_hex_string) {
-      $wkb = pack('H*',$wkb);
+      $wkb = pack('H*', $wkb);
     }
-    
-    // Open the wkb up in memory so we can examine the SRID
+
+    // Open the wkb up in memory so we can examine the SRID.
     $mem = fopen('php://memory', 'r+');
     fwrite($mem, $wkb);
     fseek($mem, 0);
@@ -29,19 +30,19 @@ class EWKB extends WKB
       $srid = NULL;
     }
     fclose($mem);
-    
-    // Run the wkb through the normal WKB reader to get the geometry
+
+    // Run the wkb through the normal WKB reader to get the geometry.
     $wkb_reader = new WKB();
     $geom = $wkb_reader->read($wkb);
-    
-    // If there is an SRID, add it to the geometry
+
+    // If there is an SRID, add it to the geometry.
     if ($srid) {
       $geom->setSRID($srid);
     }
-    
+
     return $geom;
   }
-  
+
   /**
    * Serialize geometries into an EWKB binary string.
    *
@@ -51,41 +52,47 @@ class EWKB extends WKB
    */
   public function write(Geometry $geometry, $write_as_hex = FALSE) {
     // We always write into NDR (little endian)
-    $wkb = pack('c',1);
-    
+    $wkb = pack('c', 1);
+
     switch ($geometry->getGeomType()) {
       case 'Point';
-        $wkb .= pack('L',1);
+        $wkb .= pack('L', 1);
         $wkb .= $this->writePoint($geometry);
         break;
+
       case 'LineString';
-        $wkb .= pack('L',2);
+        $wkb .= pack('L', 2);
         $wkb .= $this->writeLineString($geometry);
         break;
+
       case 'Polygon';
-        $wkb .= pack('L',3);
+        $wkb .= pack('L', 3);
         $wkb .= $this->writePolygon($geometry);
         break;
+
       case 'MultiPoint';
-        $wkb .= pack('L',4);
+        $wkb .= pack('L', 4);
         $wkb .= $this->writeMulti($geometry);
         break;
+
       case 'MultiLineString';
-        $wkb .= pack('L',5);
+        $wkb .= pack('L', 5);
         $wkb .= $this->writeMulti($geometry);
         break;
+
       case 'MultiPolygon';
-        $wkb .= pack('L',6);
+        $wkb .= pack('L', 6);
         $wkb .= $this->writeMulti($geometry);
         break;
+
       case 'GeometryCollection';
-        $wkb .= pack('L',7);
+        $wkb .= pack('L', 7);
         $wkb .= $this->writeMulti($geometry);
         break;
     }
-    
+
     if ($write_as_hex) {
-      $unpacked = unpack('H*',$wkb);
+      $unpacked = unpack('H*', $wkb);
       return $unpacked[1];
     }
     else {
diff --git a/geoPHP/lib/adapters/EWKT.class.php b/geoPHP/lib/adapters/EWKT.class.php
index e94452b..ea30d83 100755
--- a/geoPHP/lib/adapters/EWKT.class.php
+++ b/geoPHP/lib/adapters/EWKT.class.php
@@ -1,10 +1,10 @@
 <?php
+
 /**
- * EWKT (Extended Well Known Text) Adapter
+ * EWKT (Extended Well Known Text) Adapter.
  */
-class EWKT extends WKT
-{
-  
+class EWKT extends WKT {
+
   /**
    * Serialize geometries into an EWKT string.
    *
@@ -24,4 +24,5 @@ class EWKT extends WKT
       return $geometry->out('wkt');
     }
   }
+
 }
diff --git a/geoPHP/lib/adapters/GPX.class.php b/geoPHP/lib/adapters/GPX.class.php
index 9ca18b8..25941a7 100755
--- a/geoPHP/lib/adapters/GPX.class.php
+++ b/geoPHP/lib/adapters/GPX.class.php
@@ -1,180 +1,280 @@
-<?php
-/*
- * Copyright (c) Patrick Hayes
- *
- * This code is open-source and licenced under the Modified BSD License.
- * For the full copyright and license information, please view the LICENSE
- * file that was distributed with this source code.
- */
-
-/**
- * PHP Geometry/GPX encoder/decoder
- */
-class GPX extends GeoAdapter
-{
-  private $namespace = FALSE;
-  private $nss = ''; // Name-space string. eg 'georss:'
-
-  /**
-   * Read GPX string into geometry objects
-   *
-   * @param string $gpx A GPX string
-   *
-   * @return Geometry|GeometryCollection
-   */
-  public function read($gpx) {
-    return $this->geomFromText($gpx);
-  }
-
-  /**
-   * Serialize geometries into a GPX string.
-   *
-   * @param Geometry $geometry
-   *
-   * @return string The GPX string representation of the input geometries
-   */
-  public function write(Geometry $geometry, $namespace = FALSE) {
-    if ($geometry->isEmpty()) return NULL;
-    if ($namespace) {
-      $this->namespace = $namespace;
-      $this->nss = $namespace.':';    
-    }
-    return '<'.$this->nss.'gpx creator="geoPHP" version="1.0">'.$this->geometryToGPX($geometry).'</'.$this->nss.'gpx>';
-  }
-  
-  public function geomFromText($text) {
-    // Change to lower-case and strip all CDATA
-    $text = strtolower($text);
-    $text = preg_replace('/<!\[cdata\[(.*?)\]\]>/s','',$text);
-    
-    // Load into DOMDocument
-    $xmlobj = new DOMDocument();
-    @$xmlobj->loadXML($text);
-    if ($xmlobj === false) {
-      throw new Exception("Invalid GPX: ". $text);
-    }
-    
-    $this->xmlobj = $xmlobj;
-    try {
-      $geom = $this->geomFromXML();
-    } catch(InvalidText $e) {
-        throw new Exception("Cannot Read Geometry From GPX: ". $text);
-    } catch(Exception $e) {
-        throw $e;
-    }
-
-    return $geom;
-  }
-  
-  protected function geomFromXML() {
-    $geometries = array();
-    $geometries = array_merge($geometries, $this->parseWaypoints());
-    $geometries = array_merge($geometries, $this->parseTracks());
-    $geometries = array_merge($geometries, $this->parseRoutes());
-    
-    if (empty($geometries)) {
-      throw new Exception("Invalid / Empty GPX");
-    }
-    
-    return geoPHP::geometryReduce($geometries); 
-  }
-  
-  protected function childElements($xml, $nodename = '') {
-    $children = array();
-    foreach ($xml->childNodes as $child) {
-      if ($child->nodeName == $nodename) {
-        $children[] = $child;
-      }
-    }
-    return $children;
-  }
-  
-  protected function parseWaypoints() {
-    $points = array();
-    $wpt_elements = $this->xmlobj->getElementsByTagName('wpt');
-    foreach ($wpt_elements as $wpt) {
-      $lat = $wpt->attributes->getNamedItem("lat")->nodeValue;
-      $lon = $wpt->attributes->getNamedItem("lon")->nodeValue;
-      $points[] = new Point($lon, $lat);
-    }
-    return $points;
-  }
-  
-  protected function parseTracks() {
-    $lines = array();
-    $trk_elements = $this->xmlobj->getElementsByTagName('trk');
-    foreach ($trk_elements as $trk) {
-      $components = array();
-      foreach ($this->childElements($trk, 'trkseg') as $trkseg) {
-        foreach ($this->childElements($trkseg, 'trkpt') as $trkpt) {
-          $lat = $trkpt->attributes->getNamedItem("lat")->nodeValue;
-          $lon = $trkpt->attributes->getNamedItem("lon")->nodeValue;
-          $components[] = new Point($lon, $lat);
-        }
-      }
-      if ($components) {$lines[] = new LineString($components);}
-    }
-    return $lines;
-  }
-  
-  protected function parseRoutes() {
-    $lines = array();
-    $rte_elements = $this->xmlobj->getElementsByTagName('rte');
-    foreach ($rte_elements as $rte) {
-      $components = array();
-      foreach ($this->childElements($rte, 'rtept') as $rtept) {
-        $lat = $rtept->attributes->getNamedItem("lat")->nodeValue;
-        $lon = $rtept->attributes->getNamedItem("lon")->nodeValue;
-        $components[] = new Point($lon, $lat);
-      }
-      $lines[] = new LineString($components);
-    }
-    return $lines;
-  }
-  
-  protected function geometryToGPX($geom) {
-    $type = strtolower($geom->getGeomType());
-    switch ($type) {
-      case 'point':
-        return $this->pointToGPX($geom);
-        break;
-      case 'linestring':
-        return $this->linestringToGPX($geom);
-        break;
-      case 'polygon':
-      case 'multipoint':
-      case 'multilinestring':
-      case 'multipolygon':
-      case 'geometrycollection':
-        return $this->collectionToGPX($geom);
-        break;
-    }
-  }
-  
-  private function pointToGPX($geom) {
-    return '<'.$this->nss.'wpt lat="'.$geom->getY().'" lon="'.$geom->getX().'" />';
-  }
-  
-  private function linestringToGPX($geom) {
-    $gpx = '<'.$this->nss.'trk><'.$this->nss.'trkseg>';
-    
-    foreach ($geom->getComponents() as $comp) {
-      $gpx .= '<'.$this->nss.'trkpt lat="'.$comp->getY().'" lon="'.$comp->getX().'" />';
-    }
-    
-    $gpx .= '</'.$this->nss.'trkseg></'.$this->nss.'trk>';
-    
-    return $gpx;
-  }
-  
-  public function collectionToGPX($geom) {
-    $gpx = '';
-    $components = $geom->getComponents();
-    foreach ($geom->getComponents() as $comp) {
-      $gpx .= $this->geometryToGPX($comp);
-    }
-    
-    return $gpx;
-  }
-
-}
+<?php
+
+/*
+ * Copyright (c) Patrick Hayes
+ *
+ * This code is open-source and licenced under the Modified BSD License.
+ * For the full copyright and license information, please view the LICENSE
+ * file that was distributed with this source code.
+ */
+
+/**
+ * .
+ *
+ * PHP Geometry/GPX encoder/decoder.
+ */
+class GPX extends GeoAdapter {
+  private $namespace = FALSE;
+  /**
+   * Name-space string. eg 'georss:'.
+   */
+  private $nss = '';
+
+  /**
+   * .
+   *
+   * Read GPX string into geometry objects.
+   *
+   * @param string $gpx
+   *   A GPX string
+   *
+   * @return Geometry|GeometryCollection
+   */
+
+  /**
+   *
+   */
+  public function read($gpx) {
+    return $this->geomFromText($gpx);
+  }
+
+  /**
+   * .
+   *
+   * Serialize geometries into a GPX string.
+   *
+   * @param Geometry $geometry
+   *
+   * @return string The GPX string representation of the input geometries
+   */
+
+  /**
+   *
+   */
+  public function write(Geometry $geometry, $namespace = FALSE) {
+    if ($geometry->isEmpty()) {
+      return NULL;
+    }
+    if ($namespace) {
+      $this->namespace = $namespace;
+      $this->nss = $namespace . ':';
+    }
+    return '<' . $this->nss . 'gpx creator="geoPHP" version="1.0">' . $this->geometryToGPX($geometry) . '</' . $this->nss . 'gpx>';
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  public function geomFromText($text) {
+    // Change to lower-case and strip all CDATA.
+    $text = strtolower($text);
+    $text = preg_replace('/<!\[cdata\[(.*?)\]\]>/s', '', $text);
+
+    // Load into DOMDocument.
+    $xmlobj = new DOMDocument();
+    @$xmlobj->loadXML($text);
+    if ($xmlobj === FALSE) {
+      throw new Exception("Invalid GPX: " . $text);
+    }
+
+    $this->xmlobj = $xmlobj;
+    try {
+      $geom = $this->geomFromXML();
+    }
+    catch (InvalidText $e) {
+      throw new Exception("Cannot Read Geometry From GPX: " . $text);
+    }
+    catch (Exception $e) {
+      throw $e;
+    }
+
+    return $geom;
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  protected function geomFromXML() {
+    $geometries = [];
+    $geometries = array_merge($geometries, $this->parseWaypoints());
+    $geometries = array_merge($geometries, $this->parseTracks());
+    $geometries = array_merge($geometries, $this->parseRoutes());
+
+    if (empty($geometries)) {
+      throw new Exception("Invalid / Empty GPX");
+    }
+
+    return geoPHP::geometryReduce($geometries);
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  protected function childElements($xml, $nodename = '') {
+    $children = [];
+    foreach ($xml->childNodes as $child) {
+      if ($child->nodeName == $nodename) {
+        $children[] = $child;
+      }
+    }
+    return $children;
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  protected function parseWaypoints() {
+    $points = [];
+    $wpt_elements = $this->xmlobj->getElementsByTagName('wpt');
+    foreach ($wpt_elements as $wpt) {
+      $lat = $wpt->attributes->getNamedItem("lat")->nodeValue;
+      $lon = $wpt->attributes->getNamedItem("lon")->nodeValue;
+      $points[] = new Point($lon, $lat);
+    }
+    return $points;
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  protected function parseTracks() {
+    $lines = [];
+    $trk_elements = $this->xmlobj->getElementsByTagName('trk');
+    foreach ($trk_elements as $trk) {
+      $components = [];
+      foreach ($this->childElements($trk, 'trkseg') as $trkseg) {
+        foreach ($this->childElements($trkseg, 'trkpt') as $trkpt) {
+          $lat = $trkpt->attributes->getNamedItem("lat")->nodeValue;
+          $lon = $trkpt->attributes->getNamedItem("lon")->nodeValue;
+          $components[] = new Point($lon, $lat);
+        }
+      }
+      if ($components) {
+        $lines[] = new LineString($components);
+      }
+    }
+    return $lines;
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  protected function parseRoutes() {
+    $lines = [];
+    $rte_elements = $this->xmlobj->getElementsByTagName('rte');
+    foreach ($rte_elements as $rte) {
+      $components = [];
+      foreach ($this->childElements($rte, 'rtept') as $rtept) {
+        $lat = $rtept->attributes->getNamedItem("lat")->nodeValue;
+        $lon = $rtept->attributes->getNamedItem("lon")->nodeValue;
+        $components[] = new Point($lon, $lat);
+      }
+      $lines[] = new LineString($components);
+    }
+    return $lines;
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  protected function geometryToGPX($geom) {
+    $type = strtolower($geom->getGeomType());
+    switch ($type) {
+      case 'point':
+
+        return $this->pointToGPX($geom);
+
+      break;
+      case 'linestring':
+
+        return $this->linestringToGPX($geom);
+
+      break;
+      case 'polygon':
+      case 'multipoint':
+      case 'multilinestring':
+      case 'multipolygon':
+      case 'geometrycollection':
+
+        return $this->collectionToGPX($geom);
+
+      break;
+    }
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  private function pointToGPX($geom) {
+    return '<' . $this->nss . 'wpt lat="' . $geom->getY() . '" lon="' . $geom->getX() . '" />';
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  private function linestringToGPX($geom) {
+    $gpx = '<' . $this->nss . 'trk><' . $this->nss . 'trkseg>';
+
+    foreach ($geom->getComponents() as $comp) {
+      $gpx .= '<' . $this->nss . 'trkpt lat="' . $comp->getY() . '" lon="' . $comp->getX() . '" />';
+    }
+
+    $gpx .= '</' . $this->nss . 'trkseg></' . $this->nss . 'trk>';
+
+    return $gpx;
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  public function collectionToGPX($geom) {
+    $gpx = '';
+    $components = $geom->getComponents();
+    foreach ($geom->getComponents() as $comp) {
+      $gpx .= $this->geometryToGPX($comp);
+    }
+
+    return $gpx;
+  }
+
+}
diff --git a/geoPHP/lib/adapters/GeoAdapter.class.php b/geoPHP/lib/adapters/GeoAdapter.class.php
index 7217130..55d25ef 100755
--- a/geoPHP/lib/adapters/GeoAdapter.class.php
+++ b/geoPHP/lib/adapters/GeoAdapter.class.php
@@ -1,4 +1,5 @@
 <?php
+
 /*
  * (c) Patrick Hayes 2011
  *
@@ -9,23 +10,22 @@
 
 /**
  * GeoAdapter : abstract class which represents an adapter
- * for reading and writing to and from Geomtry objects
- * 
+ * for reading and writing to and from Geomtry objects.
  */
-abstract class GeoAdapter
-{
+abstract class GeoAdapter {
+
   /**
-   * Read input and return a Geomtry or GeometryCollection
-   * 
+   * Read input and return a Geomtry or GeometryCollection.
+   *
    * @return Geometry|GeometryCollection
    */
   abstract public function read($input);
-  
+
   /**
-   * Write out a Geomtry or GeometryCollection in the adapter's format
-   * 
+   * Write out a Geomtry or GeometryCollection in the adapter's format.
+   *
    * @return mixed
    */
   abstract public function write(Geometry $geometry);
-  
+
 }
diff --git a/geoPHP/lib/adapters/GeoHash.class.php b/geoPHP/lib/adapters/GeoHash.class.php
index d8a2958..acf9a89 100755
--- a/geoPHP/lib/adapters/GeoHash.class.php
+++ b/geoPHP/lib/adapters/GeoHash.class.php
@@ -1,18 +1,20 @@
 <?php
+
 /**
  * PHP Geometry GeoHash encoder/decoder.
  *
  * @author prinsmc
  * @see http://en.wikipedia.org/wiki/Geohash
- *
  */
-class GeoHash extends GeoAdapter{
+class GeoHash extends GeoAdapter {
   private $table = "0123456789bcdefghjkmnpqrstuvwxyz";
 
   /**
    * Convert the geohash to a Point. The point is 2-dimensional.
+   *
    * @return Point the converted geohash
-   * @param string $hash a geohash
+   * @param string $hash
+   *   a geohash.
    * @see GeoAdapter::read()
    */
   public function read($hash, $as_grid = FALSE) {
@@ -21,34 +23,37 @@ class GeoHash extends GeoAdapter{
       return new Point($ll['medlon'], $ll['medlat']);
     }
     else {
-      return new Polygon(array(
-        new LineString(array(
+      return new Polygon([
+        new LineString([
           new Point($ll['minlon'], $ll['maxlat']),
           new Point($ll['maxlon'], $ll['maxlat']),
           new Point($ll['maxlon'], $ll['minlat']),
           new Point($ll['minlon'], $ll['minlat']),
           new Point($ll['minlon'], $ll['maxlat']),
-        ))
-      ));
+        ]),
+      ]);
     }
   }
 
   /**
    * Convert the geometry to geohash.
+   *
    * @return string the geohash or null when the $geometry is not a Point
    * @param Point $geometry
    * @see GeoAdapter::write()
    */
-  public function write(Geometry $geometry, $precision = NULL){
-    if ($geometry->isEmpty()) return '';
+  public function write(Geometry $geometry, $precision = NULL) {
+    if ($geometry->isEmpty()) {
+      return '';
+    }
 
-    if($geometry->geometryType() === 'Point'){
+    if ($geometry->geometryType() === 'Point') {
       return $this->encodePoint($geometry, $precision);
     }
     else {
-      // The geohash is the hash grid ID that fits the envelope
+      // The geohash is the hash grid ID that fits the envelope.
       $envelope = $geometry->envelope();
-      $geohashes = array();
+      $geohashes = [];
       $geohash = '';
       foreach ($envelope->getPoints() as $point) {
         $geohashes[] = $this->encodePoint($point, 0.0000001);
@@ -74,42 +79,45 @@ class GeoHash extends GeoAdapter{
    * @author algorithm based on code by Alexander Songe <a@songe.me>
    * @see https://github.com/asonge/php-geohash/issues/1
    */
-  private function encodePoint($point, $precision = NULL){
+  private function encodePoint($point, $precision = NULL) {
     if ($precision === NULL) {
-      $lap = strlen($point->y())-strpos($point->y(),".");
-      $lop = strlen($point->x())-strpos($point->x(),".");
-      $precision = pow(10,-max($lap-1,$lop-1,0))/2;
+      $lap = strlen($point->y()) - strpos($point->y(), ".");
+      $lop = strlen($point->x()) - strpos($point->x(), ".");
+      $precision = pow(10, -max($lap - 1, $lop - 1, 0)) / 2;
     }
 
-    $minlat =  -90;
-    $maxlat =   90;
+    $minlat = -90;
+    $maxlat = 90;
     $minlon = -180;
-    $maxlon =  180;
-    $latE   =   90;
-    $lonE   =  180;
-    $i = 0;
-    $error = 180;
-    $hash='';
-    while($error>=$precision) {
+    $maxlon = 180;
+    $latE   = 90;
+    $lonE   = 180;
+    $i      = 0;
+    $error  = 180;
+    $hash   = '';
+    while ($error >= $precision) {
       $chr = 0;
-      for($b=4;$b>=0;--$b) {
-        if((1&$b) == (1&$i)) {
-          // even char, even bit OR odd char, odd bit...a lon
-          $next = ($minlon+$maxlon)/2;
-          if($point->x()>$next) {
-            $chr |= pow(2,$b);
+      for ($b = 4; $b >= 0; --$b) {
+        if ((1 & $b) == (1 & $i)) {
+          // Even char, even bit OR odd char, odd bit...a lon.
+          $next = ($minlon + $maxlon) / 2;
+          if ($point->x() > $next) {
+            $chr |= pow(2, $b);
             $minlon = $next;
-          } else {
+          }
+          else {
             $maxlon = $next;
           }
           $lonE /= 2;
-        } else {
-          // odd char, even bit OR even char, odd bit...a lat
-          $next = ($minlat+$maxlat)/2;
-          if($point->y()>$next) {
-            $chr |= pow(2,$b);
+        }
+        else {
+          // Odd char, even bit OR even char, odd bit...a lat.
+          $next = ($minlat + $maxlat) / 2;
+          if ($point->y() > $next) {
+            $chr |= pow(2, $b);
             $minlat = $next;
-          } else {
+          }
+          else {
             $maxlat = $next;
           }
           $latE /= 2;
@@ -117,40 +125,92 @@ class GeoHash extends GeoAdapter{
       }
       $hash .= $this->table[$chr];
       $i++;
-      $error = min($latE,$lonE);
+      $error = min($latE, $lonE);
     }
     return $hash;
   }
 
   /**
-   * @param string $hash a geohash
+   * @param string $hash
+   *   a geohash.
    * @author algorithm based on code by Alexander Songe <a@songe.me>
    * @see https://github.com/asonge/php-geohash/issues/1
    */
-  private function decode($hash){
-    $ll = array();
-    $minlat =  -90;
-    $maxlat =   90;
+  private function decode($hash) {
+    $ll     = [];
+    $minlat = -90;
+    $maxlat = 90;
     $minlon = -180;
-    $maxlon =  180;
-    $latE   =   90;
-    $lonE   =  180;
-    for($i=0,$c=strlen($hash);$i<$c;$i++) {
-      $v = strpos($this->table,$hash[$i]);
-      if(1&$i) {
-        if(16&$v)$minlat = ($minlat+$maxlat)/2; else $maxlat = ($minlat+$maxlat)/2;
-        if(8&$v) $minlon = ($minlon+$maxlon)/2; else $maxlon = ($minlon+$maxlon)/2;
-        if(4&$v) $minlat = ($minlat+$maxlat)/2; else $maxlat = ($minlat+$maxlat)/2;
-        if(2&$v) $minlon = ($minlon+$maxlon)/2; else $maxlon = ($minlon+$maxlon)/2;
-        if(1&$v) $minlat = ($minlat+$maxlat)/2; else $maxlat = ($minlat+$maxlat)/2;
+    $maxlon = 180;
+    $latE   = 90;
+    $lonE   = 180;
+    for ($i = 0, $c = strlen($hash); $i < $c; $i++) {
+      $v = strpos($this->table, $hash[$i]);
+      if (1 & $i) {
+        if (16 & $v) {
+          $minlat = ($minlat + $maxlat) / 2;
+        }
+        else {
+          $maxlat = ($minlat + $maxlat) / 2;
+        }
+        if (8 & $v) {
+          $minlon = ($minlon + $maxlon) / 2;
+        }
+        else {
+          $maxlon = ($minlon + $maxlon) / 2;
+        }
+        if (4 & $v) {
+          $minlat = ($minlat + $maxlat) / 2;
+        }
+        else {
+          $maxlat = ($minlat + $maxlat) / 2;
+        }
+        if (2 & $v) {
+          $minlon = ($minlon + $maxlon) / 2;
+        }
+        else {
+          $maxlon = ($minlon + $maxlon) / 2;
+        }
+        if (1 & $v) {
+          $minlat = ($minlat + $maxlat) / 2;
+        }
+        else {
+          $maxlat = ($minlat + $maxlat) / 2;
+        }
         $latE /= 8;
         $lonE /= 4;
-      } else {
-        if(16&$v)$minlon = ($minlon+$maxlon)/2; else $maxlon = ($minlon+$maxlon)/2;
-        if(8&$v) $minlat = ($minlat+$maxlat)/2; else $maxlat = ($minlat+$maxlat)/2;
-        if(4&$v) $minlon = ($minlon+$maxlon)/2; else $maxlon = ($minlon+$maxlon)/2;
-        if(2&$v) $minlat = ($minlat+$maxlat)/2; else $maxlat = ($minlat+$maxlat)/2;
-        if(1&$v) $minlon = ($minlon+$maxlon)/2; else $maxlon = ($minlon+$maxlon)/2;
+      }
+      else {
+        if (16 & $v) {
+          $minlon = ($minlon + $maxlon) / 2;
+        }
+        else {
+          $maxlon = ($minlon + $maxlon) / 2;
+        }
+        if (8 & $v) {
+          $minlat = ($minlat + $maxlat) / 2;
+        }
+        else {
+          $maxlat = ($minlat + $maxlat) / 2;
+        }
+        if (4 & $v) {
+          $minlon = ($minlon + $maxlon) / 2;
+        }
+        else {
+          $maxlon = ($minlon + $maxlon) / 2;
+        }
+        if (2 & $v) {
+          $minlat = ($minlat + $maxlat) / 2;
+        }
+        else {
+          $maxlat = ($minlat + $maxlat) / 2;
+        }
+        if (1 & $v) {
+          $minlon = ($minlon + $maxlon) / 2;
+        }
+        else {
+          $maxlon = ($minlon + $maxlon) / 2;
+        }
         $latE /= 4;
         $lonE /= 8;
       }
@@ -159,8 +219,9 @@ class GeoHash extends GeoAdapter{
     $ll['minlon'] = $minlon;
     $ll['maxlat'] = $maxlat;
     $ll['maxlon'] = $maxlon;
-    $ll['medlat'] = round(($minlat+$maxlat)/2, max(1, -round(log10($latE)))-1);
-    $ll['medlon'] = round(($minlon+$maxlon)/2, max(1, -round(log10($lonE)))-1);
+    $ll['medlat'] = round(($minlat + $maxlat) / 2, max(1, -round(log10($latE))) - 1);
+    $ll['medlon'] = round(($minlon + $maxlon) / 2, max(1, -round(log10($lonE))) - 1);
     return $ll;
   }
+
 }
diff --git a/geoPHP/lib/adapters/GeoJSON.class.php b/geoPHP/lib/adapters/GeoJSON.class.php
index abe8e92..4d02f9f 100755
--- a/geoPHP/lib/adapters/GeoJSON.class.php
+++ b/geoPHP/lib/adapters/GeoJSON.class.php
@@ -1,4 +1,5 @@
 <?php
+
 /**
  * GeoJSON class : a geojson reader/writer.
  *
@@ -6,12 +7,13 @@
  * means that if you pass it a feature, it will return the
  * geometry of that feature strip everything else.
  */
-class GeoJSON extends GeoAdapter
-{
+class GeoJSON extends GeoAdapter {
+
   /**
-   * Given an object or a string, return a Geometry
+   * Given an object or a string, return a Geometry.
    *
-   * @param mixed $input The GeoJSON string or object
+   * @param mixed $input
+   *   The GeoJSON string or object.
    *
    * @return object Geometry
    */
@@ -26,24 +28,27 @@ class GeoJSON extends GeoAdapter
       throw new Exception('Invalid JSON');
     }
 
-    // Check to see if it's a FeatureCollection
+    // Check to see if it's a FeatureCollection.
     if ($input->type == 'FeatureCollection') {
-      $geoms = array();
+      $geoms = [];
       foreach ($input->features as $feature) {
         $geoms[] = $this->read($feature);
       }
       return geoPHP::geometryReduce($geoms);
     }
 
-    // Check to see if it's a Feature
+    // Check to see if it's a Feature.
     if ($input->type == 'Feature') {
       return $this->read($input->geometry);
     }
 
-    // It's a geometry - process it
+    // It's a geometry - process it.
     return $this->objToGeom($input);
   }
 
+  /**
+   *
+   */
   private function objToGeom($obj) {
     $type = $obj->type;
 
@@ -54,52 +59,73 @@ class GeoJSON extends GeoAdapter
     return $this->$method($obj->coordinates);
   }
 
+  /**
+   *
+   */
   private function arrayToPoint($array) {
     return new Point($array[0], $array[1]);
   }
 
+  /**
+   *
+   */
   private function arrayToLineString($array) {
-    $points = array();
+    $points = [];
     foreach ($array as $comp_array) {
       $points[] = $this->arrayToPoint($comp_array);
     }
     return new LineString($points);
   }
 
+  /**
+   *
+   */
   private function arrayToPolygon($array) {
-    $lines = array();
+    $lines = [];
     foreach ($array as $comp_array) {
       $lines[] = $this->arrayToLineString($comp_array);
     }
     return new Polygon($lines);
   }
 
+  /**
+   *
+   */
   private function arrayToMultiPoint($array) {
-    $points = array();
+    $points = [];
     foreach ($array as $comp_array) {
       $points[] = $this->arrayToPoint($comp_array);
     }
     return new MultiPoint($points);
   }
 
+  /**
+   *
+   */
   private function arrayToMultiLineString($array) {
-    $lines = array();
+    $lines = [];
     foreach ($array as $comp_array) {
       $lines[] = $this->arrayToLineString($comp_array);
     }
     return new MultiLineString($lines);
   }
 
+  /**
+   *
+   */
   private function arrayToMultiPolygon($array) {
-    $polys = array();
+    $polys = [];
     foreach ($array as $comp_array) {
       $polys[] = $this->arrayToPolygon($comp_array);
     }
     return new MultiPolygon($polys);
   }
 
+  /**
+   *
+   */
   private function objToGeometryCollection($obj) {
-    $geoms = array();
+    $geoms = [];
     if (empty($obj->geometries)) {
       throw new Exception('Invalid GeoJSON: GeometryCollection with no component geometries');
     }
@@ -110,10 +136,10 @@ class GeoJSON extends GeoAdapter
   }
 
   /**
-   * Serializes an object into a geojson string
-   *
+   * Serializes an object into a geojson string.
    *
-   * @param Geometry $obj The object to serialize
+   * @param Geometry $obj
+   *   The object to serialize.
    *
    * @return string The GeoJSON string
    */
@@ -126,25 +152,29 @@ class GeoJSON extends GeoAdapter
     }
   }
 
+  /**
+   *
+   */
   public function getArray($geometry) {
     if ($geometry->getGeomType() == 'GeometryCollection') {
-      $component_array = array();
+      $component_array = [];
       foreach ($geometry->components as $component) {
-        $component_array[] = array(
+        $component_array[] = [
           'type' => $component->geometryType(),
           'coordinates' => $component->asArray(),
-        );
+        ];
       }
-      return array(
-        'type'=> 'GeometryCollection',
-        'geometries'=> $component_array,
-      );
-    }
-    else return array(
-      'type'=> $geometry->getGeomType(),
-      'coordinates'=> $geometry->asArray(),
-    );
+      return [
+        'type' => 'GeometryCollection',
+        'geometries' => $component_array,
+      ];
+    }
+    else {
+      return [
+        'type' => $geometry->getGeomType(),
+        'coordinates' => $geometry->asArray(),
+      ];
+    }
   }
-}
-
 
+}
diff --git a/geoPHP/lib/adapters/GeoRSS.class.php b/geoPHP/lib/adapters/GeoRSS.class.php
index 970b156..5bc4651 100755
--- a/geoPHP/lib/adapters/GeoRSS.class.php
+++ b/geoPHP/lib/adapters/GeoRSS.class.php
@@ -1,228 +1,338 @@
-<?php
-/*
- * Copyright (c) Patrick Hayes
- *
- * This code is open-source and licenced under the Modified BSD License.
- * For the full copyright and license information, please view the LICENSE
- * file that was distributed with this source code.
- */
-
-/**
- * PHP Geometry/GeoRSS encoder/decoder
- */
-class GeoRSS extends GeoAdapter
-{
-  private $namespace = FALSE;
-  private $nss = ''; // Name-space string. eg 'georss:'
-  
-  /**
-   * Read GeoRSS string into geometry objects
-   *
-   * @param string $georss - an XML feed containing geoRSS
-   *
-   * @return Geometry|GeometryCollection
-   */
-  public function read($gpx) {
-    return $this->geomFromText($gpx);
-  }
-
-  /**
-   * Serialize geometries into a GeoRSS string.
-   *
-   * @param Geometry $geometry
-   *
-   * @return string The georss string representation of the input geometries
-   */
-  public function write(Geometry $geometry, $namespace = FALSE) {
-    if ($namespace) {
-      $this->namespace = $namespace;
-      $this->nss = $namespace.':';    
-    }
-    return $this->geometryToGeoRSS($geometry);
-  }
-  
-  public function geomFromText($text) {
-    // Change to lower-case, strip all CDATA, and de-namespace
-    $text = strtolower($text);
-    $text = preg_replace('/<!\[cdata\[(.*?)\]\]>/s','',$text);
-        
-    // Load into DOMDOcument
-    $xmlobj = new DOMDocument();
-    @$xmlobj->loadXML($text);
-    if ($xmlobj === false) {
-      throw new Exception("Invalid GeoRSS: ". $text);
-    }
-    
-    $this->xmlobj = $xmlobj;
-    try {
-      $geom = $this->geomFromXML();
-    } catch(InvalidText $e) {
-        throw new Exception("Cannot Read Geometry From GeoRSS: ". $text);
-    } catch(Exception $e) {
-        throw $e;
-    }
-
-    return $geom;
-  }
-  
-  protected function geomFromXML() {
-    $geometries = array();
-    $geometries = array_merge($geometries, $this->parsePoints());
-    $geometries = array_merge($geometries, $this->parseLines());
-    $geometries = array_merge($geometries, $this->parsePolygons());
-    $geometries = array_merge($geometries, $this->parseBoxes());
-    $geometries = array_merge($geometries, $this->parseCircles());
-    
-    if (empty($geometries)) {
-      throw new Exception("Invalid / Empty GeoRSS");
-    }
-    
-    return geoPHP::geometryReduce($geometries); 
-  }
-  
-  protected function getPointsFromCoords($string) {
-    $coords = array();
-    $latlon = explode(' ',$string);
-    foreach ($latlon as $key => $item) {
-      if (!($key % 2)) {
-        // It's a latitude
-        $lat = $item;
-      }
-      else {
-        // It's a longitude
-        $lon = $item;
-        $coords[] = new Point($lon, $lat);
-      }
-    }
-    return $coords;
-  }
-  
-  protected function parsePoints() {
-    $points = array();
-    $pt_elements = $this->xmlobj->getElementsByTagName('point');
-    foreach ($pt_elements as $pt) {
-      $point_array = $this->getPointsFromCoords(trim($pt->firstChild->nodeValue));
-      $points[] = $point_array[0];
-    }
-    return $points;
-  }
-  
-  protected function parseLines() {
-    $lines = array();
-    $line_elements = $this->xmlobj->getElementsByTagName('line');
-    foreach ($line_elements as $line) {
-      $components = $this->getPointsFromCoords(trim($line->firstChild->nodeValue));
-      $lines[] = new LineString($components);
-    }
-    return $lines;
-  }
-  
-  protected function parsePolygons() {
-    $polygons = array();
-    $poly_elements = $this->xmlobj->getElementsByTagName('polygon');
-    foreach ($poly_elements as $poly) {
-      if ($poly->hasChildNodes()) {
-        $points = $this->getPointsFromCoords(trim($poly->firstChild->nodeValue));
-        $exterior_ring = new LineString($points);
-        $polygons[] = new Polygon(array($exterior_ring));
-      }
-      else {
-        // It's an EMPTY polygon
-        $polygons[] = new Polygon(); 
-      }
-    }
-    return $polygons;
-  }
-  
-  // Boxes are rendered into polygons
-  protected function parseBoxes() {
-    $polygons = array();
-    $box_elements = $this->xmlobj->getElementsByTagName('box');
-    foreach ($box_elements as $box) {
-      $parts = explode(' ',trim($box->firstChild->nodeValue));
-      $components = array(
-        new Point($parts[3], $parts[2]),
-        new Point($parts[3], $parts[0]),
-        new Point($parts[1], $parts[0]),
-        new Point($parts[1], $parts[2]),
-        new Point($parts[3], $parts[2]),
-      );
-      $exterior_ring = new LineString($components);
-      $polygons[] = new Polygon(array($exterior_ring));
-    }
-    return $polygons;
-  }
-
-  // Circles are rendered into points
-  // @@TODO: Add good support once we have circular-string geometry support
-  protected function parseCircles() {
-    $points = array();
-    $circle_elements = $this->xmlobj->getElementsByTagName('circle');
-    foreach ($circle_elements as $circle) {
-      $parts = explode(' ',trim($circle->firstChild->nodeValue));
-      $points[] = new Point($parts[1], $parts[0]);
-    }
-    return $points;
-  }
-  
-  protected function geometryToGeoRSS($geom) {
-    $type = strtolower($geom->getGeomType());
-    switch ($type) {
-      case 'point':
-        return $this->pointToGeoRSS($geom);
-        break;
-      case 'linestring':
-        return $this->linestringToGeoRSS($geom);
-        break;
-      case 'polygon':
-        return $this->PolygonToGeoRSS($geom);
-        break;
-      case 'multipoint':
-      case 'multilinestring':
-      case 'multipolygon':
-      case 'geometrycollection':
-        return $this->collectionToGeoRSS($geom);
-        break;
-    }
-    return $output;
-  }
-  
-  private function pointToGeoRSS($geom) {
-    return '<'.$this->nss.'point>'.$geom->getY().' '.$geom->getX().'</'.$this->nss.'point>';
-  }
-  
-
-  private function linestringToGeoRSS($geom) {
-    $output = '<'.$this->nss.'line>';
-    foreach ($geom->getComponents() as $k => $point) {
-      $output .= $point->getY().' '.$point->getX();
-      if ($k < ($geom->numGeometries() -1)) $output .= ' ';
-    }
-    $output .= '</'.$this->nss.'line>';
-    return $output;
-  }
-
-  private function polygonToGeoRSS($geom) {
-    $output = '<'.$this->nss.'polygon>';
-    $exterior_ring = $geom->exteriorRing();
-    foreach ($exterior_ring->getComponents() as $k => $point) {
-      $output .= $point->getY().' '.$point->getX();
-      if ($k < ($exterior_ring->numGeometries() -1)) $output .= ' ';
-    }
-    $output .= '</'.$this->nss.'polygon>';
-    return $output;
-  }
-  
-  public function collectionToGeoRSS($geom) {
-    $georss = '<'.$this->nss.'where>';
-    $components = $geom->getComponents();
-    foreach ($geom->getComponents() as $comp) {
-      $georss .= $this->geometryToGeoRSS($comp);
-    }
-    
-    $georss .= '</'.$this->nss.'where>';
-    
-    return $georss;
-  }
-
-}
+<?php
+
+/*
+ * Copyright (c) Patrick Hayes
+ *
+ * This code is open-source and licenced under the Modified BSD License.
+ * For the full copyright and license information, please view the LICENSE
+ * file that was distributed with this source code.
+ */
+
+/**
+ * .
+ *
+ * PHP Geometry/GeoRSS encoder/decoder.
+ */
+class GeoRSS extends GeoAdapter {
+  private $namespace = FALSE;
+  /**
+   * Name-space string. eg 'georss:'.
+   */
+  private $nss = '';
+
+  /**
+   * .
+   *
+   * Read GeoRSS string into geometry objects.
+   *
+   * @param string $georss
+   *   - an XML feed containing geoRSS
+   *
+   * @return Geometry|GeometryCollection
+   */
+
+  /**
+   *
+   */
+  public function read($gpx) {
+    return $this->geomFromText($gpx);
+  }
+
+  /**
+   * .
+   *
+   * Serialize geometries into a GeoRSS string.
+   *
+   * @param Geometry $geometry
+   *
+   * @return string The georss string representation of the input geometries
+   */
+
+  /**
+   *
+   */
+  public function write(Geometry $geometry, $namespace = FALSE) {
+    if ($namespace) {
+      $this->namespace = $namespace;
+      $this->nss = $namespace . ':';
+    }
+    return $this->geometryToGeoRSS($geometry);
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  public function geomFromText($text) {
+    // Change to lower-case, strip all CDATA, and de-namespace.
+    $text = strtolower($text);
+    $text = preg_replace('/<!\[cdata\[(.*?)\]\]>/s', '', $text);
+
+    // Load into DOMDOcument.
+    $xmlobj = new DOMDocument();
+    @$xmlobj->loadXML($text);
+    if ($xmlobj === FALSE) {
+      throw new Exception("Invalid GeoRSS: " . $text);
+    }
+
+    $this->xmlobj = $xmlobj;
+    try {
+      $geom = $this->geomFromXML();
+    }
+    catch (InvalidText $e) {
+      throw new Exception("Cannot Read Geometry From GeoRSS: " . $text);
+    }
+    catch (Exception $e) {
+      throw $e;
+    }
+
+    return $geom;
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  protected function geomFromXML() {
+    $geometries = [];
+    $geometries = array_merge($geometries, $this->parsePoints());
+    $geometries = array_merge($geometries, $this->parseLines());
+    $geometries = array_merge($geometries, $this->parsePolygons());
+    $geometries = array_merge($geometries, $this->parseBoxes());
+    $geometries = array_merge($geometries, $this->parseCircles());
+
+    if (empty($geometries)) {
+      throw new Exception("Invalid / Empty GeoRSS");
+    }
+
+    return geoPHP::geometryReduce($geometries);
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  protected function getPointsFromCoords($string) {
+    $coords = [];
+    $latlon = explode(' ', $string);
+    foreach ($latlon as $key => $item) {
+      if (!($key % 2)) {
+        // It's a latitude.
+        $lat = $item;
+      }
+      else {
+        // It's a longitude.
+        $lon = $item;
+        $coords[] = new Point($lon, $lat);
+      }
+    }
+    return $coords;
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  protected function parsePoints() {
+    $points = [];
+    $pt_elements = $this->xmlobj->getElementsByTagName('point');
+    foreach ($pt_elements as $pt) {
+      $point_array = $this->getPointsFromCoords(trim($pt->firstChild->nodeValue));
+      $points[] = $point_array[0];
+    }
+    return $points;
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  protected function parseLines() {
+    $lines = [];
+    $line_elements = $this->xmlobj->getElementsByTagName('line');
+    foreach ($line_elements as $line) {
+      $components = $this->getPointsFromCoords(trim($line->firstChild->nodeValue));
+      $lines[] = new LineString($components);
+    }
+    return $lines;
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  protected function parsePolygons() {
+    $polygons = [];
+    $poly_elements = $this->xmlobj->getElementsByTagName('polygon');
+    foreach ($poly_elements as $poly) {
+      if ($poly->hasChildNodes()) {
+        $points = $this->getPointsFromCoords(trim($poly->firstChild->nodeValue));
+        $exterior_ring = new LineString($points);
+        $polygons[] = new Polygon([$exterior_ring]);
+      }
+      else {
+        // It's an EMPTY polygon.
+        $polygons[] = new Polygon();
+      }
+    }
+    return $polygons;
+  }
+
+  // Boxes are rendered into polygons.
+
+  /**
+   *
+   */
+  protected function parseBoxes() {
+    $polygons = [];
+    $box_elements = $this->xmlobj->getElementsByTagName('box');
+    foreach ($box_elements as $box) {
+      $parts = explode(' ', trim($box->firstChild->nodeValue));
+      $components = [new Point($parts[3], $parts[2]), new Point($parts[3], $parts[0]), new Point($parts[1], $parts[0]), new Point($parts[1], $parts[2]), new Point($parts[3], $parts[2])];
+      $exterior_ring = new LineString($components);
+      $polygons[] = new Polygon([$exterior_ring]);
+    }
+    return $polygons;
+  }
+
+  // Circles are rendered into points.
+  // @@TODO: Add good support once we have circular-string geometry support
+
+  /**
+   *
+   */
+  protected function parseCircles() {
+    $points = [];
+    $circle_elements = $this->xmlobj->getElementsByTagName('circle');
+    foreach ($circle_elements as $circle) {
+      $parts = explode(' ', trim($circle->firstChild->nodeValue));
+      $points[] = new Point($parts[1], $parts[0]);
+    }
+    return $points;
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  protected function geometryToGeoRSS($geom) {
+    $type = strtolower($geom->getGeomType());
+    switch ($type) {
+      case 'point':
+
+        return $this->pointToGeoRSS($geom);
+
+      break;
+      case 'linestring':
+
+        return $this->linestringToGeoRSS($geom);
+
+      break;
+      case 'polygon':
+
+        return $this->PolygonToGeoRSS($geom);
+
+      break;
+      case 'multipoint':
+      case 'multilinestring':
+      case 'multipolygon':
+      case 'geometrycollection':
+
+        return $this->collectionToGeoRSS($geom);
+
+      break;
+    }
+    return $output;
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  private function pointToGeoRSS($geom) {
+    return '<' . $this->nss . 'point>' . $geom->getY() . ' ' . $geom->getX() . '</' . $this->nss . 'point>';
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  private function linestringToGeoRSS($geom) {
+    $output = '<' . $this->nss . 'line>';
+    foreach ($geom->getComponents() as $k => $point) {
+      $output .= $point->getY() . ' ' . $point->getX();
+      if ($k < ($geom->numGeometries() - 1)) {
+        $output .= ' ';
+      }
+    }
+    $output .= '</' . $this->nss . 'line>';
+    return $output;
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  private function polygonToGeoRSS($geom) {
+    $output = '<' . $this->nss . 'polygon>';
+    $exterior_ring = $geom->exteriorRing();
+    foreach ($exterior_ring->getComponents() as $k => $point) {
+      $output .= $point->getY() . ' ' . $point->getX();
+      if ($k < ($exterior_ring->numGeometries() - 1)) {
+        $output .= ' ';
+      }
+    }
+    $output .= '</' . $this->nss . 'polygon>';
+    return $output;
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  public function collectionToGeoRSS($geom) {
+    $georss = '<' . $this->nss . 'where>';
+    $components = $geom->getComponents();
+    foreach ($geom->getComponents() as $comp) {
+      $georss .= $this->geometryToGeoRSS($comp);
+    }
+
+    $georss .= '</' . $this->nss . 'where>';
+
+    return $georss;
+  }
+
+}
diff --git a/geoPHP/lib/adapters/GoogleGeocode.class.php b/geoPHP/lib/adapters/GoogleGeocode.class.php
index 4b40870..1c41867 100755
--- a/geoPHP/lib/adapters/GoogleGeocode.class.php
+++ b/geoPHP/lib/adapters/GoogleGeocode.class.php
@@ -1,4 +1,5 @@
 <?php
+
 /*
  * (c) Camptocamp <info@camptocamp.com>
  * (c) Patrick Hayes
@@ -9,45 +10,46 @@
  */
 
 /**
- * PHP Google Geocoder Adapter
- *
+ * PHP Google Geocoder Adapter.
  *
- * @package    geoPHP
- * @author     Patrick Hayes <patrick.d.hayes@gmail.com>
+ * @package geoPHP
+ * @author Patrick Hayes <patrick.d.hayes@gmail.com>
  */
-class GoogleGeocode extends GeoAdapter
-{
+class GoogleGeocode extends GeoAdapter {
 
   /**
-   * Read an address string or array geometry objects
+   * Read an address string or array geometry objects.
    *
    * @param string - Address to geocode
    * @param string - Type of Geometry to return. Can either be 'points' or 'bounds' (polygon)
    * @param Geometry|bounds-array - Limit the search area to within this region. For example
-   *                                by default geocoding "Cairo" will return the location of Cairo Egypt.
+   *   by default geocoding "Cairo" will return the location of Cairo Egypt.
    *                                If you pass a polygon of illinois, it will return Cairo IL.
    * @param return_multiple - Return all results in a multipoint or multipolygon
+   *
    * @return Geometry|GeometryCollection
    */
   public function read($address, $return_type = 'point', $bounds = FALSE, $return_multiple = FALSE) {
-    if (is_array($address)) $address = join(',', $address);
-    
+    if (is_array($address)) {
+      $address = join(',', $address);
+    }
+
     if (gettype($bounds) == 'object') {
       $bounds = $bounds->getBBox();
     }
     if (gettype($bounds) == 'array') {
-      $bounds_string = '&bounds='.$bounds['miny'].','.$bounds['minx'].'|'.$bounds['maxy'].','.$bounds['maxx'];
+      $bounds_string = '&bounds=' . $bounds['miny'] . ',' . $bounds['minx'] . '|' . $bounds['maxy'] . ',' . $bounds['maxx'];
     }
     else {
       $bounds_string = '';
     }
-    
+
     $url = "http://maps.googleapis.com/maps/api/geocode/json";
-    $url .= '?address='. urlencode($address);
+    $url .= '?address=' . urlencode($address);
     $url .= $bounds_string;
     $url .= '&sensor=false';
     $this->result = json_decode(@file_get_contents($url));
-    
+
     if ($this->result->status == 'OK') {
       if ($return_multiple == FALSE) {
         if ($return_type == 'point') {
@@ -59,14 +61,14 @@ class GoogleGeocode extends GeoAdapter
       }
       if ($return_multiple == TRUE) {
         if ($return_type == 'point') {
-          $points = array();
+          $points = [];
           foreach ($this->result->results as $delta => $item) {
             $points[] = $this->getPoint($delta);
           }
           return new MultiPoint($points);
         }
         if ($return_type == 'bounds' || $return_type == 'polygon') {
-          $polygons = array();
+          $polygons = [];
           foreach ($this->result->results as $delta => $item) {
             $polygons[] = $this->getPolygon($delta);
           }
@@ -75,8 +77,12 @@ class GoogleGeocode extends GeoAdapter
       }
     }
     else {
-      if ($this->result->status) throw new Exception('Error in Google Geocoder: '.$this->result->status);
-      else throw new Exception('Unknown error in Google Geocoder');
+      if ($this->result->status) {
+        throw new Exception('Error in Google Geocoder: ' . $this->result->status);
+      }
+      else {
+        throw new Exception('Unknown error in Google Geocoder');
+      }
       return FALSE;
     }
   }
@@ -85,7 +91,8 @@ class GoogleGeocode extends GeoAdapter
    * Serialize geometries into a WKT string.
    *
    * @param Geometry $geometry
-   * @param string $return_type Should be either 'string' or 'array'
+   * @param string $return_type
+   *   Should be either 'string' or 'array'.
    *
    * @return string Does a reverse geocode of the geometry
    */
@@ -93,12 +100,12 @@ class GoogleGeocode extends GeoAdapter
     $centroid = $geometry->getCentroid();
     $lat = $centroid->getY();
     $lon = $centroid->getX();
-    
+
     $url = "http://maps.googleapis.com/maps/api/geocode/json";
-    $url .= '?latlng='.$lat.','.$lon;
+    $url .= '?latlng=' . $lat . ',' . $lon;
     $url .= '&sensor=false';
     $this->result = json_decode(@file_get_contents($url));
-    
+
     if ($this->result->status == 'OK') {
       if ($return_type == 'string') {
         return $this->result->results[0]->formatted_address;
@@ -108,51 +115,74 @@ class GoogleGeocode extends GeoAdapter
       }
     }
     else {
-      if ($this->result->status) throw new Exception('Error in Google Reverse Geocoder: '.$this->result->status);
-      else throw new Exception('Unknown error in Google Reverse Geocoder');
+      if ($this->result->status) {
+        throw new Exception('Error in Google Reverse Geocoder: ' . $this->result->status);
+      }
+      else {
+        throw new Exception('Unknown error in Google Reverse Geocoder');
+      }
       return FALSE;
     }
   }
-  
+
+  /**
+   *
+   */
   private function getPoint($delta = 0) {
     $lat = $this->result->results[$delta]->geometry->location->lat;
     $lon = $this->result->results[$delta]->geometry->location->lng;
     return new Point($lon, $lat);
   }
 
+  /**
+   *
+   */
   private function getPolygon($delta = 0) {
-    $points = array (
+    $points = [
       $this->getTopLeft($delta),
       $this->getTopRight($delta),
       $this->getBottomRight($delta),
       $this->getBottomLeft($delta),
       $this->getTopLeft($delta),
-    );
+    ];
     $outer_ring = new LineString($points);
-    return new Polygon(array($outer_ring));
+    return new Polygon([$outer_ring]);
   }
 
+  /**
+   *
+   */
   private function getTopLeft($delta = 0) {
     $lat = $this->result->results[$delta]->geometry->bounds->northeast->lat;
     $lon = $this->result->results[$delta]->geometry->bounds->southwest->lng;
     return new Point($lon, $lat);
   }
 
+  /**
+   *
+   */
   private function getTopRight($delta = 0) {
     $lat = $this->result->results[$delta]->geometry->bounds->northeast->lat;
     $lon = $this->result->results[$delta]->geometry->bounds->northeast->lng;
     return new Point($lon, $lat);
   }
-  
+
+  /**
+   *
+   */
   private function getBottomLeft($delta = 0) {
     $lat = $this->result->results[$delta]->geometry->bounds->southwest->lat;
     $lon = $this->result->results[$delta]->geometry->bounds->southwest->lng;
-     return new Point($lon, $lat);
+    return new Point($lon, $lat);
   }
 
+  /**
+   *
+   */
   private function getBottomRight($delta = 0) {
     $lat = $this->result->results[$delta]->geometry->bounds->southwest->lat;
     $lon = $this->result->results[$delta]->geometry->bounds->northeast->lng;
     return new Point($lon, $lat);
   }
+
 }
diff --git a/geoPHP/lib/adapters/KML.class.php b/geoPHP/lib/adapters/KML.class.php
index 904b0e6..899cdea 100755
--- a/geoPHP/lib/adapters/KML.class.php
+++ b/geoPHP/lib/adapters/KML.class.php
@@ -1,259 +1,379 @@
-<?php
-/*
- * Copyright (c) Patrick Hayes
- * Copyright (c) 2010-2011, Arnaud Renevier
- *
- * This code is open-source and licenced under the Modified BSD License.
- * For the full copyright and license information, please view the LICENSE
- * file that was distributed with this source code.
- */
-
-/**
- * PHP Geometry/KML encoder/decoder
- *
- * Mainly inspired/adapted from OpenLayers( http://www.openlayers.org )
- *   Openlayers/format/WKT.js
- *
- * @package    sfMapFishPlugin
- * @subpackage GeoJSON
- * @author     Camptocamp <info@camptocamp.com>
- */
-class KML extends GeoAdapter
-{
-  private $namespace = FALSE;
-  private $nss = ''; // Name-space string. eg 'georss:'
-
-  /**
-   * Read KML string into geometry objects
-   *
-   * @param string $kml A KML string
-   *
-   * @return Geometry|GeometryCollection
-   */
-  public function read($kml) {
-    return $this->geomFromText($kml);
-  }
-
-  /**
-   * Serialize geometries into a KML string.
-   *
-   * @param Geometry $geometry
-   *
-   * @return string The KML string representation of the input geometries
-   */
-  public function write(Geometry $geometry, $namespace = FALSE) {
-    if ($namespace) {
-      $this->namespace = $namespace;
-      $this->nss = $namespace.':';
-    }
-    return $this->geometryToKML($geometry);
-  }
-
-  public function geomFromText($text) {
-
-    // Change to lower-case and strip all CDATA
-    $text = mb_strtolower($text, mb_detect_encoding($text));
-    $text = preg_replace('/<!\[cdata\[(.*?)\]\]>/s','',$text);
-
-    // Load into DOMDOcument
-    $xmlobj = new DOMDocument();
-    @$xmlobj->loadXML($text);
-    if ($xmlobj === false) {
-      throw new Exception("Invalid KML: ". $text);
-    }
-
-    $this->xmlobj = $xmlobj;
-    try {
-      $geom = $this->geomFromXML();
-    } catch(InvalidText $e) {
-        throw new Exception("Cannot Read Geometry From KML: ". $text);
-    } catch(Exception $e) {
-        throw $e;
-    }
-
-    return $geom;
-  }
-
-  protected function geomFromXML() {
-    $geometries = array();
-    $geom_types = geoPHP::geometryList();
-    $placemark_elements = $this->xmlobj->getElementsByTagName('placemark');
-    if ($placemark_elements->length) {
-      foreach ($placemark_elements as $placemark) {
-        foreach ($placemark->childNodes as $child) {
-          // Node names are all the same, except for MultiGeometry, which maps to GeometryCollection
-          $node_name = $child->nodeName == 'multigeometry' ? 'geometrycollection' : $child->nodeName;
-          if (array_key_exists($node_name, $geom_types)) {
-            $function = 'parse'.$geom_types[$node_name];
-            $geometries[] = $this->$function($child);
-          }
-        }
-      }
-    }
-    else {
-      // The document does not have a placemark, try to create a valid geometry from the root element
-      $node_name = $this->xmlobj->documentElement->nodeName == 'multigeometry' ? 'geometrycollection' : $this->xmlobj->documentElement->nodeName;
-      if (array_key_exists($node_name, $geom_types)) {
-        $function = 'parse'.$geom_types[$node_name];
-        $geometries[] = $this->$function($this->xmlobj->documentElement);
-      }
-    }
-    return geoPHP::geometryReduce($geometries);
-  }
-
-  protected function childElements($xml, $nodename = '') {
-    $children = array();
-    if ($xml->childNodes) {
-      foreach ($xml->childNodes as $child) {
-        if ($child->nodeName == $nodename) {
-          $children[] = $child;
-        }
-      }
-    }
-    return $children;
-  }
-
-  protected function parsePoint($xml) {
-    $coordinates = $this->_extractCoordinates($xml);
-    return new Point($coordinates[0][0],$coordinates[0][1]);
-  }
-
-  protected function parseLineString($xml) {
-    $coordinates = $this->_extractCoordinates($xml);
-    $point_array = array();
-    foreach ($coordinates as $set) {
-      $point_array[] = new Point($set[0],$set[1]);
-    }
-    return new LineString($point_array);
-  }
-
-  protected function parsePolygon($xml) {
-    $components = array();
-
-    $outer_boundary_element_a = $this->childElements($xml, 'outerboundaryis');
-    $outer_boundary_element = $outer_boundary_element_a[0];
-    $outer_ring_element_a = $this->childElements($outer_boundary_element, 'linearring');
-    $outer_ring_element = $outer_ring_element_a[0];
-    $components[] = $this->parseLineString($outer_ring_element);
-
-    if (count($components) != 1) {
-      throw new Exception("Invalid KML");
-    }
-
-    $inner_boundary_element_a = $this->childElements($xml, 'innerboundaryis');
-    if (count($inner_boundary_element_a)) {
-      foreach ($inner_boundary_element_a as $inner_boundary_element) {
-        foreach ($this->childElements($inner_boundary_element, 'linearring') as $inner_ring_element) {
-          $components[] = $this->parseLineString($inner_ring_element);
-        }
-      }
-    }
-
-    return new Polygon($components);
-  }
-
-  protected function parseGeometryCollection($xml) {
-    $components = array();
-    $geom_types = geoPHP::geometryList();
-    foreach ($xml->childNodes as $child) {
-      $nodeName = ($child->nodeName == 'linearring') ? 'linestring' : $child->nodeName;
-      if (array_key_exists($nodeName, $geom_types)) {
-        $function = 'parse'.$geom_types[$nodeName];
-        $components[] = $this->$function($child);
-      }
-    }
-    return new GeometryCollection($components);
-  }
-
-  protected function _extractCoordinates($xml) {
-    $coord_elements = $this->childElements($xml, 'coordinates');
-    $coordinates = array();
-    if (count($coord_elements)) {
-      $coord_sets = explode(' ', $coord_elements[0]->nodeValue);
-      foreach ($coord_sets as $set_string) {
-        $set_string = trim($set_string);
-        if ($set_string) {
-          $set_array = explode(',',$set_string);
-          if (count($set_array) >= 2) {
-            $coordinates[] = $set_array;
-          }
-        }
-      }
-    }
-
-    return $coordinates;
-  }
-
-  private function geometryToKML($geom) {
-    $type = strtolower($geom->getGeomType());
-    switch ($type) {
-      case 'point':
-        return $this->pointToKML($geom);
-        break;
-      case 'linestring':
-        return $this->linestringToKML($geom);
-        break;
-      case 'polygon':
-        return $this->polygonToKML($geom);
-        break;
-      case 'multipoint':
-      case 'multilinestring':
-      case 'multipolygon':
-      case 'geometrycollection':
-        return $this->collectionToKML($geom);
-        break;
-    }
-  }
-
-  private function pointToKML($geom) {
-    return '<'.$this->nss.'Point><'.$this->nss.'coordinates>'.$geom->getX().",".$geom->getY().'</'.$this->nss.'coordinates></'.$this->nss.'Point>';
-  }
-
-  private function linestringToKML($geom, $type = FALSE) {
-    if (!$type) {
-      $type = $geom->getGeomType();
-    }
-
-    $str = '<'.$this->nss . $type .'>';
-
-    if (!$geom->isEmpty()) {
-      $str .= '<'.$this->nss.'coordinates>';
-      $i=0;
-      foreach ($geom->getComponents() as $comp) {
-        if ($i != 0) $str .= ' ';
-        $str .= $comp->getX() .','. $comp->getY();
-        $i++;
-      }
-
-      $str .= '</'.$this->nss.'coordinates>';
-    }
-
-    $str .= '</'. $this->nss . $type .'>';
-
-    return $str;
-  }
-
-  public function polygonToKML($geom) {
-    $components = $geom->getComponents();
-    if (!empty($components)) {
-      $str = '<'.$this->nss.'outerBoundaryIs>' . $this->linestringToKML($components[0], 'LinearRing') . '</'.$this->nss.'outerBoundaryIs>';
-      foreach (array_slice($components, 1) as $comp) {
-        $str .= '<'.$this->nss.'innerBoundaryIs>' . $this->linestringToKML($comp) . '</'.$this->nss.'innerBoundaryIs>';
-      }
-    }
-
-    return '<'.$this->nss.'Polygon>'. $str .'</'.$this->nss.'Polygon>';
-  }
-
-  public function collectionToKML($geom) {
-    $components = $geom->getComponents();
-    $str = '<'.$this->nss.'MultiGeometry>';
-    foreach ($geom->getComponents() as $comp) {
-      $sub_adapter = new KML();
-      $str .= $sub_adapter->write($comp);
-    }
-
-    return $str .'</'.$this->nss.'MultiGeometry>';
-  }
-
-}
+<?php
+
+/*
+ * Copyright (c) Patrick Hayes
+ * Copyright (c) 2010-2011, Arnaud Renevier
+ *
+ * This code is open-source and licenced under the Modified BSD License.
+ * For the full copyright and license information, please view the LICENSE
+ * file that was distributed with this source code.
+ */
+
+/**
+ * .
+ *
+ * PHP Geometry/KML encoder/decoder.
+ *
+ * Mainly inspired/adapted from OpenLayers( http://www.openlayers.org )
+ *   Openlayers/format/WKT.js.
+ *
+ * @package sfMapFishPlugin
+ * @subpackage GeoJSON
+ * @author Camptocamp <info@camptocamp.com>
+ */
+class KML extends GeoAdapter {
+  private $namespace = FALSE;
+  /**
+   * Name-space string. eg 'georss:'.
+   */
+  private $nss = '';
+
+  /**
+   * .
+   *
+   * Read KML string into geometry objects.
+   *
+   * @param string $kml
+   *   A KML string
+   *
+   * @return Geometry|GeometryCollection
+   */
+
+  /**
+   *
+   */
+  public function read($kml) {
+    return $this->geomFromText($kml);
+  }
+
+  /**
+   * .
+   *
+   * Serialize geometries into a KML string.
+   *
+   * @param Geometry $geometry
+   *
+   * @return string The KML string representation of the input geometries
+   */
+
+  /**
+   *
+   */
+  public function write(Geometry $geometry, $namespace = FALSE) {
+    if ($namespace) {
+      $this->namespace = $namespace;
+      $this->nss = $namespace . ':';
+    }
+    return $this->geometryToKML($geometry);
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  public function geomFromText($text) {
+    // Change to lower-case and strip all CDATA.
+    $text = mb_strtolower($text, mb_detect_encoding($text));
+    $text = preg_replace('/<!\[cdata\[(.*?)\]\]>/s', '', $text);
+
+    // Load into DOMDOcument.
+    $xmlobj = new DOMDocument();
+    @$xmlobj->loadXML($text);
+    if ($xmlobj === FALSE) {
+      throw new Exception("Invalid KML: " . $text);
+    }
+
+    $this->xmlobj = $xmlobj;
+    try {
+      $geom = $this->geomFromXML();
+    }
+    catch (InvalidText $e) {
+      throw new Exception("Cannot Read Geometry From KML: " . $text);
+    }
+    catch (Exception $e) {
+      throw $e;
+    }
+
+    return $geom;
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  protected function geomFromXML() {
+    $geometries = [];
+    $geom_types = geoPHP::geometryList();
+    $placemark_elements = $this->xmlobj->getElementsByTagName('placemark');
+    if ($placemark_elements->length) {
+      foreach ($placemark_elements as $placemark) {
+        foreach ($placemark->childNodes as $child) {
+          // Node names are all the same, except for MultiGeometry, which maps to GeometryCollection.
+          $node_name = $child->nodeName == 'multigeometry' ? 'geometrycollection' : $child->nodeName;
+          if (array_key_exists($node_name, $geom_types)) {
+            $function = 'parse' . $geom_types[$node_name];
+            $geometries[] = $this->$function($child);
+          }
+        }
+      }
+    }
+    else {
+      // The document does not have a placemark, try to create a valid geometry from the root element.
+      $node_name = $this->xmlobj->documentElement->nodeName == 'multigeometry' ? 'geometrycollection' : $this->xmlobj->documentElement->nodeName;
+      if (array_key_exists($node_name, $geom_types)) {
+        $function = 'parse' . $geom_types[$node_name];
+        $geometries[] = $this->$function($this->xmlobj->documentElement);
+      }
+    }
+    return geoPHP::geometryReduce($geometries);
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  protected function childElements($xml, $nodename = '') {
+    $children = [];
+    if ($xml->childNodes) {
+      foreach ($xml->childNodes as $child) {
+        if ($child->nodeName == $nodename) {
+          $children[] = $child;
+        }
+      }
+    }
+    return $children;
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  protected function parsePoint($xml) {
+    $coordinates = $this->_extractCoordinates($xml);
+    return new Point($coordinates[0][0], $coordinates[0][1]);
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  protected function parseLineString($xml) {
+    $coordinates = $this->_extractCoordinates($xml);
+    $point_array = [];
+    foreach ($coordinates as $set) {
+      $point_array[] = new Point($set[0], $set[1]);
+    }
+    return new LineString($point_array);
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  protected function parsePolygon($xml) {
+    $components = [];
+
+    $outer_boundary_element_a = $this->childElements($xml, 'outerboundaryis');
+    $outer_boundary_element = $outer_boundary_element_a[0];
+    $outer_ring_element_a = $this->childElements($outer_boundary_element, 'linearring');
+    $outer_ring_element = $outer_ring_element_a[0];
+    $components[] = $this->parseLineString($outer_ring_element);
+
+    if (count($components) != 1) {
+      throw new Exception("Invalid KML");
+    }
+
+    $inner_boundary_element_a = $this->childElements($xml, 'innerboundaryis');
+    if (count($inner_boundary_element_a)) {
+      foreach ($inner_boundary_element_a as $inner_boundary_element) {
+        foreach ($this->childElements($inner_boundary_element, 'linearring') as $inner_ring_element) {
+          $components[] = $this->parseLineString($inner_ring_element);
+        }
+      }
+    }
+
+    return new Polygon($components);
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  protected function parseGeometryCollection($xml) {
+    $components = [];
+    $geom_types = geoPHP::geometryList();
+    foreach ($xml->childNodes as $child) {
+      $nodeName = ($child->nodeName == 'linearring') ? 'linestring' : $child->nodeName;
+      if (array_key_exists($nodeName, $geom_types)) {
+        $function = 'parse' . $geom_types[$nodeName];
+        $components[] = $this->$function($child);
+      }
+    }
+    return new GeometryCollection($components);
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  protected function _extractCoordinates($xml) {
+    $coord_elements = $this->childElements($xml, 'coordinates');
+    $coordinates = [];
+    if (count($coord_elements)) {
+      $coord_sets = explode(' ', $coord_elements[0]->nodeValue);
+      foreach ($coord_sets as $set_string) {
+        $set_string = trim($set_string);
+        if ($set_string) {
+          $set_array = explode(',', $set_string);
+          if (count($set_array) >= 2) {
+            $coordinates[] = $set_array;
+          }
+        }
+      }
+    }
+
+    return $coordinates;
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  private function geometryToKML($geom) {
+    $type = strtolower($geom->getGeomType());
+    switch ($type) {
+      case 'point':
+
+        return $this->pointToKML($geom);
+
+      break;
+      case 'linestring':
+
+        return $this->linestringToKML($geom);
+
+      break;
+      case 'polygon':
+
+        return $this->polygonToKML($geom);
+
+      break;
+      case 'multipoint':
+      case 'multilinestring':
+      case 'multipolygon':
+      case 'geometrycollection':
+
+        return $this->collectionToKML($geom);
+
+      break;
+    }
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  private function pointToKML($geom) {
+    return '<' . $this->nss . 'Point><' . $this->nss . 'coordinates>' . $geom->getX() . "," . $geom->getY() . '</' . $this->nss . 'coordinates></' . $this->nss . 'Point>';
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  private function linestringToKML($geom, $type = FALSE) {
+    if (!$type) {
+      $type = $geom->getGeomType();
+    }
+
+    $str = '<' . $this->nss . $type . '>';
+
+    if (!$geom->isEmpty()) {
+      $str .= '<' . $this->nss . 'coordinates>';
+      $i = 0;
+      foreach ($geom->getComponents() as $comp) {
+        if ($i != 0) {
+          $str .= ' ';
+        }
+        $str .= $comp->getX() . ',' . $comp->getY();
+        $i++;
+      }
+
+      $str .= '</' . $this->nss . 'coordinates>';
+    }
+
+    $str .= '</' . $this->nss . $type . '>';
+
+    return $str;
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  public function polygonToKML($geom) {
+    $components = $geom->getComponents();
+    if (!empty($components)) {
+      $str = '<' . $this->nss . 'outerBoundaryIs>' . $this->linestringToKML($components[0], 'LinearRing') . '</' . $this->nss . 'outerBoundaryIs>';
+      foreach (array_slice($components, 1) as $comp) {
+        $str .= '<' . $this->nss . 'innerBoundaryIs>' . $this->linestringToKML($comp) . '</' . $this->nss . 'innerBoundaryIs>';
+      }
+    }
+
+    return '<' . $this->nss . 'Polygon>' . $str . '</' . $this->nss . 'Polygon>';
+  }
+
+  /**
+   * .
+   */
+
+  /**
+   *
+   */
+  public function collectionToKML($geom) {
+    $components = $geom->getComponents();
+    $str = '<' . $this->nss . 'MultiGeometry>';
+    foreach ($geom->getComponents() as $comp) {
+      $sub_adapter = new KML();
+      $str .= $sub_adapter->write($comp);
+    }
+
+    return $str . '</' . $this->nss . 'MultiGeometry>';
+  }
+
+}
diff --git a/geoPHP/lib/adapters/WKB.class.php b/geoPHP/lib/adapters/WKB.class.php
index 0a19104..f183fa3 100755
--- a/geoPHP/lib/adapters/WKB.class.php
+++ b/geoPHP/lib/adapters/WKB.class.php
@@ -1,242 +1,316 @@
-<?php
-/*
- * (c) Patrick Hayes
- *
- * This code is open-source and licenced under the Modified BSD License.
- * For the full copyright and license information, please view the LICENSE
- * file that was distributed with this source code.
- */
-
-/**
- * PHP Geometry/WKB encoder/decoder
- *
- */
-class WKB extends GeoAdapter
-{
-
-  private $dimension = 2;
-  private $z = FALSE;
-  private $m = FALSE;
-
-  /**
-   * Read WKB into geometry objects
-   *
-   * @param string $wkb
-   *   Well-known-binary string
-   * @param bool $is_hex_string
-   *   If this is a hexedecimal string that is in need of packing
-   *
-   * @return Geometry
-   */
-  public function read($wkb, $is_hex_string = FALSE) {
-    if ($is_hex_string) {
-      $wkb = pack('H*',$wkb);
-    }
-
-    if (empty($wkb)) {
-      throw new Exception('Cannot read empty WKB geometry. Found ' . gettype($wkb));
-    }
-
-    $mem = fopen('php://memory', 'r+');
-    fwrite($mem, $wkb);
-    fseek($mem, 0);
-
-    $geometry = $this->getGeometry($mem);
-    fclose($mem);
-    return $geometry;
-  }
-
-  function getGeometry(&$mem) {
-    $base_info = unpack("corder/ctype/cz/cm/cs", fread($mem, 5));
-    if ($base_info['order'] !== 1) {
-      throw new Exception('Only NDR (little endian) SKB format is supported at the moment');
-    }
-
-    if ($base_info['z']) {
-      $this->dimension++;
-      $this->z = TRUE;
-    }
-    if ($base_info['m']) {
-      $this->dimension++;
-      $this->m = TRUE;
-    }
-
-    // If there is SRID information, ignore it - use EWKB Adapter to get SRID support
-    if ($base_info['s']) {
-      fread($mem, 4);
-    }
-
-    switch ($base_info['type']) {
-      case 1:
-        return $this->getPoint($mem);
-      case 2:
-        return $this->getLinstring($mem);
-      case 3:
-        return $this->getPolygon($mem);
-      case 4:
-        return $this->getMulti($mem,'point');
-      case 5:
-        return $this->getMulti($mem,'line');
-      case 6:
-        return $this->getMulti($mem,'polygon');
-      case 7:
-        return $this->getMulti($mem,'geometry');
-    }
-  }
-
-  function getPoint(&$mem) {
-    $point_coords = unpack("d*", fread($mem,$this->dimension*8));
-    return new Point($point_coords[1],$point_coords[2]);
-  }
-
-  function getLinstring(&$mem) {
-    // Get the number of points expected in this string out of the first 4 bytes
-    $line_length = unpack('L',fread($mem,4));
-
-    // Return an empty linestring if there is no line-length
-    if (!$line_length[1]) return new LineString();
-
-    // Read the nubmer of points x2 (each point is two coords) into decimal-floats
-    $line_coords = unpack('d*', fread($mem,$line_length[1]*$this->dimension*8));
-
-    // We have our coords, build up the linestring
-    $components = array();
-    $i = 1;
-    $num_coords = count($line_coords);
-    while ($i <= $num_coords) {
-      $components[] = new Point($line_coords[$i],$line_coords[$i+1]);
-      $i += 2;
-    }
-    return new LineString($components);
-  }
-
-  function getPolygon(&$mem) {
-    // Get the number of linestring expected in this poly out of the first 4 bytes
-    $poly_length = unpack('L',fread($mem,4));
-
-    $components = array();
-    $i = 1;
-    while ($i <= $poly_length[1]) {
-      $components[] = $this->getLinstring($mem);
-      $i++;
-    }
-    return new Polygon($components);
-  }
-
-  function getMulti(&$mem, $type) {
-    // Get the number of items expected in this multi out of the first 4 bytes
-    $multi_length = unpack('L',fread($mem,4));
-
-    $components = array();
-    $i = 1;
-    while ($i <= $multi_length[1]) {
-      $components[] = $this->getGeometry($mem);
-      $i++;
-    }
-    switch ($type) {
-      case 'point':
-        return new MultiPoint($components);
-      case 'line':
-        return new MultiLineString($components);
-      case 'polygon':
-        return new MultiPolygon($components);
-      case 'geometry':
-        return new GeometryCollection($components);
-    }
-  }
-
-  /**
-   * Serialize geometries into WKB string.
-   *
-   * @param Geometry $geometry
-   *
-   * @return string The WKB string representation of the input geometries
-   */
-  public function write(Geometry $geometry, $write_as_hex = FALSE) {
-    // We always write into NDR (little endian)
-    $wkb = pack('c',1);
-
-    switch ($geometry->getGeomType()) {
-      case 'Point';
-        $wkb .= pack('L',1);
-        $wkb .= $this->writePoint($geometry);
-        break;
-      case 'LineString';
-        $wkb .= pack('L',2);
-        $wkb .= $this->writeLineString($geometry);
-        break;
-      case 'Polygon';
-        $wkb .= pack('L',3);
-        $wkb .= $this->writePolygon($geometry);
-        break;
-      case 'MultiPoint';
-        $wkb .= pack('L',4);
-        $wkb .= $this->writeMulti($geometry);
-        break;
-      case 'MultiLineString';
-        $wkb .= pack('L',5);
-        $wkb .= $this->writeMulti($geometry);
-        break;
-      case 'MultiPolygon';
-        $wkb .= pack('L',6);
-        $wkb .= $this->writeMulti($geometry);
-        break;
-      case 'GeometryCollection';
-        $wkb .= pack('L',7);
-        $wkb .= $this->writeMulti($geometry);
-        break;
-    }
-
-    if ($write_as_hex) {
-      $unpacked = unpack('H*',$wkb);
-      return $unpacked[1];
-    }
-    else {
-      return $wkb;
-    }
-  }
-
-  function writePoint($point) {
-    // Set the coords
-    $wkb = pack('dd',$point->x(), $point->y());
-
-    return $wkb;
-  }
-
-  function writeLineString($line) {
-    // Set the number of points in this line
-    $wkb = pack('L',$line->numPoints());
-
-    // Set the coords
-    foreach ($line->getComponents() as $point) {
-      $wkb .= pack('dd',$point->x(), $point->y());
-    }
-
-    return $wkb;
-  }
-
-  function writePolygon($poly) {
-    // Set the number of lines in this poly
-    $wkb = pack('L',$poly->numGeometries());
-
-    // Write the lines
-    foreach ($poly->getComponents() as $line) {
-      $wkb .= $this->writeLineString($line);
-    }
-
-    return $wkb;
-  }
-
-  function writeMulti($geometry) {
-    // Set the number of components
-    $wkb = pack('L',$geometry->numGeometries());
-
-    // Write the components
-    foreach ($geometry->getComponents() as $component) {
-      $wkb .= $this->write($component);
-    }
-
-    return $wkb;
-  }
-
-}
+<?php
+
+/*
+ * (c) Patrick Hayes
+ *
+ * This code is open-source and licenced under the Modified BSD License.
+ * For the full copyright and license information, please view the LICENSE
+ * file that was distributed with this source code.
+ */
+
+/**
+ * .
+ *
+ * PHP Geometry/WKB encoder/decoder.
+ */
+class WKB extends GeoAdapter {
+  private $dimension = 2;
+  private $z = FALSE;
+  private $m = FALSE;
+
+  /**
+   * .
+   *
+   * Read WKB into geometry objects.
+   *
+   * @param string $wkb
+   *   Well-known-binary string.
+   * @param bool $is_hex_string
+   *   If this is a hexedecimal string that is in need of packing.
+   *
+   * @return Geometry
+   */
+
+  /**
+   *
+   */
+  public function read($wkb, $is_hex_string = FALSE) {
+    if ($is_hex_string) {
+      $wkb = pack('H*', $wkb);
+    }
+
+    if (empty($wkb)) {
+      throw new Exception('Cannot read empty WKB geometry. Found ' . gettype($wkb));
+    }
+
+    $mem = fopen('php://memory', 'r+');
+    fwrite($mem, $wkb);
+    fseek($mem, 0);
+
+    $geometry = $this->getGeometry($mem);
+    fclose($mem);
+    return $geometry;
+  }
+
+  /**
+   *
+   */
+  public function getGeometry(&$mem) {
+    $base_info = unpack("corder/ctype/cz/cm/cs", fread($mem, 5));
+    if ($base_info['order'] !== 1) {
+      throw new Exception('Only NDR (little endian) SKB format is supported at the moment');
+    }
+
+    if ($base_info['z']) {
+      $this->dimension++;
+      $this->z = TRUE;
+    }
+    if ($base_info['m']) {
+      $this->dimension++;
+      $this->m = TRUE;
+    }
+
+    // If there is SRID information, ignore it - use EWKB Adapter to get SRID support.
+    if ($base_info['s']) {
+      fread($mem, 4);
+    }
+
+    switch ($base_info['type']) {
+      case 1:
+
+        return $this->getPoint($mem);
+
+      case 2:
+
+        return $this->getLinstring($mem);
+
+      case 3:
+
+        return $this->getPolygon($mem);
+
+      case 4:
+
+        return $this->getMulti($mem, 'point');
+
+      case 5:
+
+        return $this->getMulti($mem, 'line');
+
+      case 6:
+
+        return $this->getMulti($mem, 'polygon');
+
+      case 7:
+
+        return $this->getMulti($mem, 'geometry');
+    }
+  }
+
+  /**
+   *
+   */
+  public function getPoint(&$mem) {
+    $point_coords = unpack("d*", fread($mem, $this->dimension * 8));
+    return new Point($point_coords[1], $point_coords[2]);
+  }
+
+  /**
+   *
+   */
+  public function getLinstring(&$mem) {
+    // Get the number of points expected in this string out of the first 4 bytes.
+    $line_length = unpack('L', fread($mem, 4));
+
+    // Return an empty linestring if there is no line-length.
+    if (!$line_length[1]) {
+      return new LineString();
+    }
+
+    // Read the nubmer of points x2 (each point is two coords) into decimal-floats.
+    $line_coords = unpack('d*', fread($mem, $line_length[1] * $this->dimension * 8));
+
+    // We have our coords, build up the linestring.
+    $components = [];
+    $i = 1;
+    $num_coords = count($line_coords);
+    while ($i <= $num_coords) {
+      $components[] = new Point($line_coords[$i], $line_coords[$i + 1]);
+      $i += 2;
+    }
+    return new LineString($components);
+  }
+
+  /**
+   *
+   */
+  public function getPolygon(&$mem) {
+    // Get the number of linestring expected in this poly out of the first 4 bytes.
+    $poly_length = unpack('L', fread($mem, 4));
+
+    $components = [];
+    $i = 1;
+    while ($i <= $poly_length[1]) {
+      $components[] = $this->getLinstring($mem);
+      $i++;
+    }
+    return new Polygon($components);
+  }
+
+  /**
+   *
+   */
+  public function getMulti(&$mem, $type) {
+    // Get the number of items expected in this multi out of the first 4 bytes.
+    $multi_length = unpack('L', fread($mem, 4));
+
+    $components = [];
+    $i = 1;
+    while ($i <= $multi_length[1]) {
+      $components[] = $this->getGeometry($mem);
+      $i++;
+    }
+    switch ($type) {
+      case 'point':
+
+        return new MultiPoint($components);
+
+      case 'line':
+
+        return new MultiLineString($components);
+
+      case 'polygon':
+
+        return new MultiPolygon($components);
+
+      case 'geometry':
+
+        return new GeometryCollection($components);
+    }
+  }
+
+  /**
+   * .
+   *
+   * Serialize geometries into WKB string.
+   *
+   * @param Geometry $geometry
+   *
+   * @return string The WKB string representation of the input geometries
+   */
+
+  /**
+   *
+   */
+  public function write(Geometry $geometry, $write_as_hex = FALSE) {
+    // We always write into NDR (little endian)
+    $wkb = pack('c', 1);
+
+    switch ($geometry->getGeomType()) {
+      case 'Point';
+        $wkb .= pack('L', 1);
+        $wkb .= $this->writePoint($geometry);
+
+        break;
+
+      case 'LineString';
+        $wkb .= pack('L', 2);
+        $wkb .= $this->writeLineString($geometry);
+
+        break;
+
+      case 'Polygon';
+        $wkb .= pack('L', 3);
+        $wkb .= $this->writePolygon($geometry);
+
+        break;
+
+      case 'MultiPoint';
+        $wkb .= pack('L', 4);
+        $wkb .= $this->writeMulti($geometry);
+
+        break;
+
+      case 'MultiLineString';
+        $wkb .= pack('L', 5);
+        $wkb .= $this->writeMulti($geometry);
+
+        break;
+
+      case 'MultiPolygon';
+        $wkb .= pack('L', 6);
+        $wkb .= $this->writeMulti($geometry);
+
+        break;
+
+      case 'GeometryCollection';
+        $wkb .= pack('L', 7);
+        $wkb .= $this->writeMulti($geometry);
+
+        break;
+    }
+
+    if ($write_as_hex) {
+      $unpacked = unpack('H*', $wkb);
+      return $unpacked[1];
+    }
+    else {
+      return $wkb;
+    }
+  }
+
+  /**
+   *
+   */
+  public function writePoint($point) {
+    // Set the coords.
+    $wkb = pack('dd', $point->x(), $point->y());
+
+    return $wkb;
+  }
+
+  /**
+   *
+   */
+  public function writeLineString($line) {
+    // Set the number of points in this line.
+    $wkb = pack('L', $line->numPoints());
+
+    // Set the coords.
+    foreach ($line->getComponents() as $point) {
+      $wkb .= pack('dd', $point->x(), $point->y());
+    }
+
+    return $wkb;
+  }
+
+  /**
+   *
+   */
+  public function writePolygon($poly) {
+    // Set the number of lines in this poly.
+    $wkb = pack('L', $poly->numGeometries());
+
+    // Write the lines.
+    foreach ($poly->getComponents() as $line) {
+      $wkb .= $this->writeLineString($line);
+    }
+
+    return $wkb;
+  }
+
+  /**
+   *
+   */
+  public function writeMulti($geometry) {
+    // Set the number of components.
+    $wkb = pack('L', $geometry->numGeometries());
+
+    // Write the components.
+    foreach ($geometry->getComponents() as $component) {
+      $wkb .= $this->write($component);
+    }
+
+    return $wkb;
+  }
+
+}
diff --git a/geoPHP/lib/adapters/WKT.class.php b/geoPHP/lib/adapters/WKT.class.php
index bc25529..cf058e5 100755
--- a/geoPHP/lib/adapters/WKT.class.php
+++ b/geoPHP/lib/adapters/WKT.class.php
@@ -1,32 +1,33 @@
 <?php
+
 /**
- * WKT (Well Known Text) Adapter
+ * WKT (Well Known Text) Adapter.
  */
-class WKT extends GeoAdapter
-{
-  
+class WKT extends GeoAdapter {
+
   /**
-   * Read WKT string into geometry objects
+   * Read WKT string into geometry objects.
    *
-   * @param string $WKT A WKT string
+   * @param string $WKT
+   *   A WKT string.
    *
    * @return Geometry
    */
   public function read($wkt) {
     $wkt = trim($wkt);
-    
-    // If it contains a ';', then it contains additional SRID data
-    if (strpos($wkt,';')) {
+
+    // If it contains a ';', then it contains additional SRID data.
+    if (strpos($wkt, ';')) {
       $parts = explode(';', $wkt);
       $wkt = $parts[1];
-      $eparts = explode('=',$parts[0]);
+      $eparts = explode('=', $parts[0]);
       $srid = $eparts[1];
     }
     else {
       $srid = NULL;
     }
-    
-    // If geos is installed, then we take a shortcut and let it parse the WKT
+
+    // If geos is installed, then we take a shortcut and let it parse the WKT.
     if (geoPHP::geosInstalled()) {
       $reader = new GEOSWKTReader();
       if ($srid) {
@@ -34,161 +35,225 @@ class WKT extends GeoAdapter
         $geom->setSRID($srid);
         return $geom;
       }
-      else { 
+      else {
         return geoPHP::geosToGeometry($reader->read($wkt));
       }
     }
     $wkt = str_replace(', ', ',', $wkt);
-    
+
     // For each geometry type, check to see if we have a match at the
-    // beggining of the string. If we do, then parse using that type
+    // beggining of the string. If we do, then parse using that type.
     foreach (geoPHP::geometryList() as $geom_type) {
       $wkt_geom = strtoupper($geom_type);
       if (strtoupper(substr($wkt, 0, strlen($wkt_geom))) == $wkt_geom) {
         $data_string = $this->getDataString($wkt, $wkt_geom);
-        $method = 'parse'.$geom_type;
-        
+        $method = 'parse' . $geom_type;
+
         if ($srid) {
           $geom = $this->$method($data_string);
           $geom->setSRID($srid);
           return $geom;
         }
-        else { 
+        else {
           return $this->$method($data_string);
         }
-        
+
       }
     }
   }
-  
+
+  /**
+   *
+   */
   private function parsePoint($data_string) {
     $data_string = $this->trimParens($data_string);
-    $parts = explode(' ',$data_string);
+    $parts = explode(' ', $data_string);
     return new Point($parts[0], $parts[1]);
   }
 
+  /**
+   *
+   */
   private function parseLineString($data_string) {
     $data_string = $this->trimParens($data_string);
 
-    // If it's marked as empty, then return an empty line
-    if ($data_string == 'EMPTY') return new LineString();
-    
-    $parts = explode(',',$data_string);
-    $points = array();
+    // If it's marked as empty, then return an empty line.
+    if ($data_string == 'EMPTY') {
+      return new LineString();
+    }
+
+    $parts = explode(',', $data_string);
+    $points = [];
     foreach ($parts as $part) {
       $points[] = $this->parsePoint($part);
     }
     return new LineString($points);
   }
 
+  /**
+   *
+   */
   private function parsePolygon($data_string) {
     $data_string = $this->trimParens($data_string);
-    
-    // If it's marked as empty, then return an empty polygon
-    if ($data_string == 'EMPTY') return new Polygon();
-    
-    $parts = explode('),(',$data_string);
-    $lines = array();
+
+    // If it's marked as empty, then return an empty polygon.
+    if ($data_string == 'EMPTY') {
+      return new Polygon();
+    }
+
+    $parts = explode('),(', $data_string);
+    $lines = [];
     foreach ($parts as $part) {
-      if (!$this->beginsWith($part,'(')) $part = '(' . $part;
-      if (!$this->endsWith($part,')'))   $part = $part . ')';
+      if (!$this->beginsWith($part, '(')) {
+        $part = '(' . $part;
+      }
+      if (!$this->endsWith($part, ')')) {
+        $part = $part . ')';
+      }
       $lines[] = $this->parseLineString($part);
     }
     return new Polygon($lines);
   }
 
+  /**
+   *
+   */
   private function parseMultiPoint($data_string) {
     $data_string = $this->trimParens($data_string);
-    
-    // If it's marked as empty, then return an empty MutiPoint
-    if ($data_string == 'EMPTY') return new MultiPoint();
-    
-    $parts = explode(',',$data_string);
-    $points = array();
+
+    // If it's marked as empty, then return an empty MutiPoint.
+    if ($data_string == 'EMPTY') {
+      return new MultiPoint();
+    }
+
+    $parts = explode(',', $data_string);
+    $points = [];
     foreach ($parts as $part) {
       $points[] = $this->parsePoint($part);
     }
     return new MultiPoint($points);
   }
-  
+
+  /**
+   *
+   */
   private function parseMultiLineString($data_string) {
     $data_string = $this->trimParens($data_string);
 
-    // If it's marked as empty, then return an empty multi-linestring
-    if ($data_string == 'EMPTY') return new MultiLineString();
-    
-    $parts = explode('),(',$data_string);
-    $lines = array();
+    // If it's marked as empty, then return an empty multi-linestring.
+    if ($data_string == 'EMPTY') {
+      return new MultiLineString();
+    }
+
+    $parts = explode('),(', $data_string);
+    $lines = [];
     foreach ($parts as $part) {
-      // Repair the string if the explode broke it
-      if (!$this->beginsWith($part,'(')) $part = '(' . $part;
-      if (!$this->endsWith($part,')'))   $part = $part . ')';
+      // Repair the string if the explode broke it.
+      if (!$this->beginsWith($part, '(')) {
+        $part = '(' . $part;
+      }
+      if (!$this->endsWith($part, ')')) {
+        $part = $part . ')';
+      }
       $lines[] = $this->parseLineString($part);
     }
     return new MultiLineString($lines);
   }
 
+  /**
+   *
+   */
   private function parseMultiPolygon($data_string) {
     $data_string = $this->trimParens($data_string);
 
-    // If it's marked as empty, then return an empty multi-polygon
-    if ($data_string == 'EMPTY') return new MultiPolygon();
-    
-    $parts = explode(')),((',$data_string);
-    $polys = array();
+    // If it's marked as empty, then return an empty multi-polygon.
+    if ($data_string == 'EMPTY') {
+      return new MultiPolygon();
+    }
+
+    $parts = explode(')),((', $data_string);
+    $polys = [];
     foreach ($parts as $part) {
-      // Repair the string if the explode broke it
-      if (!$this->beginsWith($part,'((')) $part = '((' . $part;
-      if (!$this->endsWith($part,'))'))   $part = $part . '))';
+      // Repair the string if the explode broke it.
+      if (!$this->beginsWith($part, '((')) {
+        $part = '((' . $part;
+      }
+      if (!$this->endsWith($part, '))')) {
+        $part = $part . '))';
+      }
       $polys[] = $this->parsePolygon($part);
     }
     return new MultiPolygon($polys);
   }
 
+  /**
+   *
+   */
   private function parseGeometryCollection($data_string) {
     $data_string = $this->trimParens($data_string);
 
-    // If it's marked as empty, then return an empty geom-collection
-    if ($data_string == 'EMPTY') return new GeometryCollection();
-    
-    $geometries = array();
-    $matches = array();
+    // If it's marked as empty, then return an empty geom-collection.
+    if ($data_string == 'EMPTY') {
+      return new GeometryCollection();
+    }
+
+    $geometries = [];
+    $matches = [];
     $str = preg_replace('/,\s*([A-Za-z])/', '|$1', $data_string);
     $components = explode('|', trim($str));
-    
+
     foreach ($components as $component) {
       $geometries[] = $this->read($component);
     }
     return new GeometryCollection($geometries);
   }
 
+  /**
+   *
+   */
   protected function getDataString($wkt, $type) {
     return substr($wkt, strlen($type));
   }
-  
+
   /**
-   * Trim the parenthesis and spaces
+   * Trim the parenthesis and spaces.
    */
   protected function trimParens($str) {
     $str = trim($str);
-    
-    // We want to only strip off one set of parenthesis
+
+    // We want to only strip off one set of parenthesis.
     if ($this->beginsWith($str, '(')) {
-      return substr($str,1,-1);
+      return substr($str, 1, -1);
+    }
+    else {
+      return $str;
     }
-    else return $str;
   }
-  
+
+  /**
+   *
+   */
   protected function beginsWith($str, $char) {
-    if (substr($str,0,strlen($char)) == $char) return TRUE;
-    else return FALSE;
+    if (substr($str, 0, strlen($char)) == $char) {
+      return TRUE;
+    }
+    else {
+      return FALSE;
+    }
   }
 
+  /**
+   *
+   */
   protected function endsWith($str, $char) {
-    if (substr($str,(0 - strlen($char))) == $char) return TRUE;
-    else return FALSE;
+    if (substr($str, (0 - strlen($char))) == $char) {
+      return TRUE;
+    }
+    else {
+      return FALSE;
+    }
   }
-    
+
   /**
    * Serialize geometries into a WKT string.
    *
@@ -197,51 +262,56 @@ class WKT extends GeoAdapter
    * @return string The WKT string representation of the input geometries
    */
   public function write(Geometry $geometry) {
-    // If geos is installed, then we take a shortcut and let it write the WKT
+    // If geos is installed, then we take a shortcut and let it write the WKT.
     if (geoPHP::geosInstalled()) {
       $writer = new GEOSWKTWriter();
       $writer->setTrim(TRUE);
       return $writer->write($geometry->geos());
     }
-    
+
     if ($geometry->isEmpty()) {
-      return strtoupper($geometry->geometryType()).' EMPTY';
+      return strtoupper($geometry->geometryType()) . ' EMPTY';
     }
-    else if ($data = $this->extractData($geometry)) {
-      return strtoupper($geometry->geometryType()).' ('.$data.')';
+    elseif ($data = $this->extractData($geometry)) {
+      return strtoupper($geometry->geometryType()) . ' (' . $data . ')';
     }
   }
-  
+
   /**
-   * Extract geometry to a WKT string
+   * Extract geometry to a WKT string.
    *
-   * @param Geometry $geometry A Geometry object
+   * @param Geometry $geometry
+   *   A Geometry object.
    *
    * @return string
    */
   public function extractData($geometry) {
-    $parts = array();
+    $parts = [];
     switch ($geometry->geometryType()) {
       case 'Point':
-        return $geometry->getX().' '.$geometry->getY();
+        return $geometry->getX() . ' ' . $geometry->getY();
+
       case 'LineString':
         foreach ($geometry->getComponents() as $component) {
           $parts[] = $this->extractData($component);
         }
         return implode(', ', $parts);
+
       case 'Polygon':
       case 'MultiPoint':
       case 'MultiLineString':
       case 'MultiPolygon':
         foreach ($geometry->getComponents() as $component) {
-          $parts[] = '('.$this->extractData($component).')';
+          $parts[] = '(' . $this->extractData($component) . ')';
         }
         return implode(', ', $parts);
+
       case 'GeometryCollection':
         foreach ($geometry->getComponents() as $component) {
-          $parts[] = strtoupper($component->geometryType()).' ('.$this->extractData($component).')';
+          $parts[] = strtoupper($component->geometryType()) . ' (' . $this->extractData($component) . ')';
         }
         return implode(', ', $parts);
     }
   }
+
 }
diff --git a/geoPHP/lib/geometry/Collection.class.php b/geoPHP/lib/geometry/Collection.class.php
index a97666c..3ffbae0 100755
--- a/geoPHP/lib/geometry/Collection.class.php
+++ b/geoPHP/lib/geometry/Collection.class.php
@@ -1,23 +1,23 @@
 <?php
 
 /**
- * Collection: Abstract class for compound geometries
+ * Collection: Abstract class for compound geometries.
  *
  * A geometry is a collection if it is made up of other
  * component geometries. Therefore everything but a Point
  * is a Collection. For example a LingString is a collection
  * of Points. A Polygon is a collection of LineStrings etc.
  */
-abstract class Collection extends Geometry
-{
-  public $components = array();
+abstract class Collection extends Geometry {
+  public $components = [];
 
   /**
-   * Constructor: Checks and sets component geometries
+   * Constructor: Checks and sets component geometries.
    *
-   * @param array $components array of geometries
+   * @param array $components
+   *   array of geometries.
    */
-  public function __construct($components = array()) {
+  public function __construct($components = []) {
     if (!is_array($components)) {
       throw new Exception("Component geometries must be passed as an array");
     }
@@ -32,7 +32,7 @@ abstract class Collection extends Geometry
   }
 
   /**
-   * Returns Collection component geometries
+   * Returns Collection component geometries.
    *
    * @return array
    */
@@ -40,8 +40,13 @@ abstract class Collection extends Geometry
     return $this->components;
   }
 
+  /**
+   *
+   */
   public function centroid() {
-    if ($this->isEmpty()) return NULL;
+    if ($this->isEmpty()) {
+      return NULL;
+    }
 
     if ($this->geos()) {
       $geos_centroid = $this->geos()->centroid();
@@ -50,7 +55,7 @@ abstract class Collection extends Geometry
       }
     }
 
-    // As a rough estimate, we say that the centroid of a colletion is the centroid of it's envelope
+    // As a rough estimate, we say that the centroid of a colletion is the centroid of it's envelope.
     // @@TODO: Make this the centroid of the convexHull
     // Note: Outside of polygons, geometryCollections and the trivial case of points, there is no standard on what a "centroid" is
     $centroid = $this->envelope()->centroid();
@@ -58,8 +63,13 @@ abstract class Collection extends Geometry
     return $centroid;
   }
 
+  /**
+   *
+   */
   public function getBBox() {
-    if ($this->isEmpty()) return NULL;
+    if ($this->isEmpty()) {
+      return NULL;
+    }
 
     if ($this->geos()) {
       $envelope = $this->geos()->envelope();
@@ -68,20 +78,20 @@ abstract class Collection extends Geometry
       }
 
       $geos_ring = $envelope->exteriorRing();
-      return array(
+      return [
         'maxy' => $geos_ring->pointN(3)->getY(),
         'miny' => $geos_ring->pointN(1)->getY(),
         'maxx' => $geos_ring->pointN(1)->getX(),
         'minx' => $geos_ring->pointN(3)->getX(),
-      );
+      ];
     }
 
-    // Go through each component and get the max and min x and y
+    // Go through each component and get the max and min x and y.
     $i = 0;
     foreach ($this->components as $component) {
       $component_bbox = $component->getBBox();
 
-      // On the first run through, set the bbox to the component bbox
+      // On the first run through, set the bbox to the component bbox.
       if ($i == 0) {
         $maxx = $component_bbox['maxx'];
         $maxy = $component_bbox['maxy'];
@@ -89,7 +99,7 @@ abstract class Collection extends Geometry
         $miny = $component_bbox['miny'];
       }
 
-      // Do a check and replace on each boundary, slowly growing the bbox
+      // Do a check and replace on each boundary, slowly growing the bbox.
       $maxx = $component_bbox['maxx'] > $maxx ? $component_bbox['maxx'] : $maxx;
       $maxy = $component_bbox['maxy'] > $maxy ? $component_bbox['maxy'] : $maxy;
       $minx = $component_bbox['minx'] < $minx ? $component_bbox['minx'] : $minx;
@@ -97,22 +107,28 @@ abstract class Collection extends Geometry
       $i++;
     }
 
-    return array(
+    return [
       'maxy' => $maxy,
       'miny' => $miny,
       'maxx' => $maxx,
       'minx' => $minx,
-    );
+    ];
   }
 
+  /**
+   *
+   */
   public function asArray() {
-    $array = array();
+    $array = [];
     foreach ($this->components as $component) {
       $array[] = $component->asArray();
     }
     return $array;
   }
 
+  /**
+   *
+   */
   public function area() {
     if ($this->geos()) {
       return $this->geos()->area();
@@ -125,36 +141,48 @@ abstract class Collection extends Geometry
     return $area;
   }
 
-  // By default, the boundary of a collection is the boundary of it's components
+  /**
+   * By default, the boundary of a collection is the boundary of it's components.
+   */
   public function boundary() {
-    if ($this->isEmpty()) return new LineString();
+    if ($this->isEmpty()) {
+      return new LineString();
+    }
 
     if ($this->geos()) {
       return $this->geos()->boundary();
     }
 
-    $components_boundaries = array();
+    $components_boundaries = [];
     foreach ($this->components as $component) {
       $components_boundaries[] = $component->boundary();
     }
     return geoPHP::geometryReduce($components_boundaries);
   }
 
+  /**
+   *
+   */
   public function numGeometries() {
     return count($this->components);
   }
 
-  // Note that the standard is 1 based indexing
+  /**
+   * Note that the standard is 1 based indexing.
+   */
   public function geometryN($n) {
     $n = intval($n);
-    if (array_key_exists($n-1, $this->components)) {
-      return $this->components[$n-1];
+    if (array_key_exists($n - 1, $this->components)) {
+      return $this->components[$n - 1];
     }
     else {
       return NULL;
     }
   }
 
+  /**
+   *
+   */
   public function length() {
     $length = 0;
     foreach ($this->components as $delta => $component) {
@@ -163,6 +191,9 @@ abstract class Collection extends Geometry
     return $length;
   }
 
+  /**
+   *
+   */
   public function greatCircleLength($radius = 6378137) {
     $length = 0;
     foreach ($this->components as $component) {
@@ -171,6 +202,9 @@ abstract class Collection extends Geometry
     return $length;
   }
 
+  /**
+   *
+   */
   public function haversineLength() {
     $length = 0;
     foreach ($this->components as $component) {
@@ -179,6 +213,9 @@ abstract class Collection extends Geometry
     return $length;
   }
 
+  /**
+   *
+   */
   public function dimension() {
     $dimension = 0;
     foreach ($this->components as $component) {
@@ -189,19 +226,26 @@ abstract class Collection extends Geometry
     return $dimension;
   }
 
-  // A collection is empty if it has no components OR all it's components are empty
+  /**
+   * A collection is empty if it has no components OR all it's components are empty.
+   */
   public function isEmpty() {
     if (!count($this->components)) {
       return TRUE;
     }
     else {
       foreach ($this->components as $component) {
-        if (!$component->isEmpty()) return FALSE;
+        if (!$component->isEmpty()) {
+          return FALSE;
+        }
       }
       return TRUE;
     }
   }
 
+  /**
+   *
+   */
   public function numPoints() {
     $num = 0;
     foreach ($this->components as $component) {
@@ -210,14 +254,20 @@ abstract class Collection extends Geometry
     return $num;
   }
 
+  /**
+   *
+   */
   public function getPoints() {
-    $points = array();
+    $points = [];
     foreach ($this->components as $component) {
       $points = array_merge($points, $component->getPoints());
     }
     return $points;
   }
 
+  /**
+   *
+   */
   public function equals($geometry) {
     if ($this->geos()) {
       return $this->geos()->equals($geometry->geos());
@@ -226,14 +276,13 @@ abstract class Collection extends Geometry
     // To test for equality we check to make sure that there is a matching point
     // in the other geometry for every point in this geometry.
     // This is slightly more strict than the standard, which
-    // uses Within(A,B) = true and Within(B,A) = true
+    // uses Within(A,B) = true and Within(B,A) = true.
     // @@TODO: Eventually we could fix this by using some sort of simplification
     // method that strips redundant vertices (that are all in a row)
-
     $this_points = $this->getPoints();
     $other_points = $geometry->getPoints();
 
-    // First do a check to make sure they have the same number of vertices
+    // First do a check to make sure they have the same number of vertices.
     if (count($this_points) != count($other_points)) {
       return FALSE;
     }
@@ -252,43 +301,116 @@ abstract class Collection extends Geometry
       }
     }
 
-    // All points match, return TRUE
+    // All points match, return TRUE.
     return TRUE;
   }
 
+  /**
+   *
+   */
   public function isSimple() {
     if ($this->geos()) {
       return $this->geos()->isSimple();
     }
 
-    // A collection is simple if all it's components are simple
+    // A collection is simple if all it's components are simple.
     foreach ($this->components as $component) {
-      if (!$component->isSimple()) return FALSE;
+      if (!$component->isSimple()) {
+        return FALSE;
+      }
     }
 
     return TRUE;
   }
 
+  /**
+   *
+   */
   public function explode() {
-    $parts = array();
+    $parts = [];
     foreach ($this->components as $component) {
       $parts = array_merge($parts, $component->explode());
     }
     return $parts;
   }
 
-  // Not valid for this geometry type
-  // --------------------------------
-  public function x()                { return NULL; }
-  public function y()                { return NULL; }
-  public function startPoint()       { return NULL; }
-  public function endPoint()         { return NULL; }
-  public function isRing()           { return NULL; }
-  public function isClosed()         { return NULL; }
-  public function pointN($n)         { return NULL; }
-  public function exteriorRing()     { return NULL; }
-  public function numInteriorRings() { return NULL; }
-  public function interiorRingN($n)  { return NULL; }
-  public function pointOnSurface()   { return NULL; }
-}
+  // Not valid for this geometry type.
+
+  /**
+   * --------------------------------.
+   */
+  public function x() {
+    return NULL;
+  }
+
+  /**
+   *
+   */
+  public function y() {
+    return NULL;
+  }
+
+  /**
+   *
+   */
+  public function startPoint() {
+    return NULL;
+  }
+
+  /**
+   *
+   */
+  public function endPoint() {
+    return NULL;
+  }
+
+  /**
+   *
+   */
+  public function isRing() {
+    return NULL;
+  }
+
+  /**
+   *
+   */
+  public function isClosed() {
+    return NULL;
+  }
+
+  /**
+   *
+   */
+  public function pointN($n) {
+    return NULL;
+  }
+
+  /**
+   *
+   */
+  public function exteriorRing() {
+    return NULL;
+  }
+
+  /**
+   *
+   */
+  public function numInteriorRings() {
+    return NULL;
+  }
+
+  /**
+   *
+   */
+  public function interiorRingN($n) {
+    return NULL;
+  }
 
+  /**
+   *
+   */
+  public function pointOnSurface() {
+    return NULL;
+  }
+
+}
diff --git a/geoPHP/lib/geometry/Geometry.class.php b/geoPHP/lib/geometry/Geometry.class.php
index 8807841..1c0ed90 100755
--- a/geoPHP/lib/geometry/Geometry.class.php
+++ b/geoPHP/lib/geometry/Geometry.class.php
@@ -1,54 +1,176 @@
 <?php
 
 /**
- * Geometry abstract class
+ * Geometry abstract class.
  */
-abstract class Geometry
-{
+abstract class Geometry {
   private   $geos = NULL;
   protected $srid = NULL;
   protected $geom_type;
 
-  // Abtract: Standard
-  // -----------------
+  // Abtract: Standard.
+
+  /**
+   * -----------------.
+   */
   abstract public function area();
+
+  /**
+   *
+   */
   abstract public function boundary();
+
+  /**
+   *
+   */
   abstract public function centroid();
+
+  /**
+   *
+   */
   abstract public function length();
+
+  /**
+   *
+   */
   abstract public function y();
+
+  /**
+   *
+   */
   abstract public function x();
+
+  /**
+   *
+   */
   abstract public function numGeometries();
+
+  /**
+   *
+   */
   abstract public function geometryN($n);
+
+  /**
+   *
+   */
   abstract public function startPoint();
+
+  /**
+   *
+   */
   abstract public function endPoint();
-  abstract public function isRing();            // Mssing dependancy
-  abstract public function isClosed();          // Missing dependancy
+
+  // Mssing dependancy.
+
+  /**
+   *
+   */
+  abstract public function isRing();
+
+  /**
+   *
+   */
+
+  /**
+   * Missing dependancy.
+   */
+  abstract public function isClosed();
+
+  /**
+   *
+   */
   abstract public function numPoints();
+
+  /**
+   *
+   */
   abstract public function pointN($n);
+
+  /**
+   *
+   */
   abstract public function exteriorRing();
+
+  /**
+   *
+   */
   abstract public function numInteriorRings();
+
+  /**
+   *
+   */
   abstract public function interiorRingN($n);
+
+  /**
+   *
+   */
   abstract public function dimension();
+
+  /**
+   *
+   */
   abstract public function equals($geom);
+
+  /**
+   *
+   */
   abstract public function isEmpty();
+
+  /**
+   *
+   */
   abstract public function isSimple();
 
-  // Abtract: Non-Standard
-  // ---------------------
+  // Abtract: Non-Standard.
+
+  /**
+   * ---------------------.
+   */
   abstract public function getBBox();
+
+  /**
+   *
+   */
   abstract public function asArray();
+
+  /**
+   *
+   */
   abstract public function getPoints();
+
+  /**
+   *
+   */
   abstract public function explode();
-  abstract public function greatCircleLength(); //meters
-  abstract public function haversineLength(); //degrees
 
+  // Meters.
+
+  /**
+   *
+   */
+  abstract public function greatCircleLength();
+
+  /**
+   *
+   */
+
+  /**
+   * Degrees.
+   */
+  abstract public function haversineLength();
 
-  // Public: Standard -- Common to all geometries
-  // --------------------------------------------
+  // Public: Standard -- Common to all geometries.
+
+  /**
+   * --------------------------------------------.
+   */
   public function SRID() {
     return $this->srid;
   }
 
+  /**
+   *
+   */
   public function setSRID($srid) {
     if ($this->geos()) {
       $this->geos()->setSRID($srid);
@@ -56,34 +178,44 @@ abstract class Geometry
     $this->srid = $srid;
   }
 
+  /**
+   *
+   */
   public function envelope() {
-    if ($this->isEmpty()) return new Polygon();
+    if ($this->isEmpty()) {
+      return new Polygon();
+    }
 
     if ($this->geos()) {
       return geoPHP::geosToGeometry($this->geos()->envelope());
     }
 
     $bbox = $this->getBBox();
-    $points = array (
-      new Point($bbox['maxx'],$bbox['miny']),
-      new Point($bbox['maxx'],$bbox['maxy']),
-      new Point($bbox['minx'],$bbox['maxy']),
-      new Point($bbox['minx'],$bbox['miny']),
-      new Point($bbox['maxx'],$bbox['miny']),
-    );
+    $points = [
+      new Point($bbox['maxx'], $bbox['miny']),
+      new Point($bbox['maxx'], $bbox['maxy']),
+      new Point($bbox['minx'], $bbox['maxy']),
+      new Point($bbox['minx'], $bbox['miny']),
+      new Point($bbox['maxx'], $bbox['miny']),
+    ];
 
     $outer_boundary = new LineString($points);
-    return new Polygon(array($outer_boundary));
+    return new Polygon([$outer_boundary]);
   }
 
+  /**
+   *
+   */
   public function geometryType() {
     return $this->geom_type;
   }
 
   // Public: Non-Standard -- Common to all geometries
-  // ------------------------------------------------
+  // ------------------------------------------------.
 
-  // $this->out($format, $other_args);
+  /**
+   * $this->out($format, $other_args);.
+   */
   public function out() {
     $args = func_get_args();
 
@@ -93,61 +225,90 @@ abstract class Geometry
     $processor = new $processor_type();
 
     array_unshift($args, $this);
-    $result = call_user_func_array(array($processor, 'write'), $args);
+    $result = call_user_func_array([$processor, 'write'], $args);
 
     return $result;
   }
 
+  // Public: Aliases.
 
-  // Public: Aliases
-  // ---------------
+  /**
+   * ---------------.
+   */
   public function getCentroid() {
     return $this->centroid();
   }
 
+  /**
+   *
+   */
   public function getArea() {
     return $this->area();
   }
 
+  /**
+   *
+   */
   public function getX() {
     return $this->x();
   }
 
+  /**
+   *
+   */
   public function getY() {
     return $this->y();
   }
 
+  /**
+   *
+   */
   public function getGeos() {
     return $this->geos();
   }
 
+  /**
+   *
+   */
   public function getGeomType() {
     return $this->geometryType();
   }
 
+  /**
+   *
+   */
   public function getSRID() {
     return $this->SRID();
   }
 
+  /**
+   *
+   */
   public function asText() {
     return $this->out('wkt');
   }
 
+  /**
+   *
+   */
   public function asBinary() {
     return $this->out('wkb');
   }
 
-  // Public: GEOS Only Functions
-  // ---------------------------
+  // Public: GEOS Only Functions.
+
+  /**
+   * ---------------------------.
+   */
   public function geos() {
-    // If it's already been set, just return it
+    // If it's already been set, just return it.
     if ($this->geos && geoPHP::geosInstalled()) {
       return $this->geos;
     }
-    // It hasn't been set yet, generate it
+    // It hasn't been set yet, generate it.
     if (geoPHP::geosInstalled()) {
       $reader = new GEOSWKBReader();
-      $this->geos = $reader->readHEX($this->out('wkb',TRUE));
+      $this->geos = $reader->readHEX($this->out('wkb', TRUE));
     }
     else {
       $this->geos = FALSE;
@@ -155,22 +316,34 @@ abstract class Geometry
     return $this->geos;
   }
 
+  /**
+   *
+   */
   public function setGeos($geos) {
     $this->geos = $geos;
   }
 
+  /**
+   *
+   */
   public function pointOnSurface() {
     if ($this->geos()) {
       return geoPHP::geosToGeometry($this->geos()->pointOnSurface());
     }
   }
 
+  /**
+   *
+   */
   public function equalsExact(Geometry $geometry) {
     if ($this->geos()) {
       return $this->geos()->equalsExact($geometry->geos());
     }
   }
 
+  /**
+   *
+   */
   public function relate(Geometry $geometry, $pattern = NULL) {
     if ($this->geos()) {
       if ($pattern) {
@@ -182,43 +355,63 @@ abstract class Geometry
     }
   }
 
+  /**
+   *
+   */
   public function checkValidity() {
     if ($this->geos()) {
       return $this->geos()->checkValidity();
     }
   }
 
+  /**
+   *
+   */
   public function buffer($distance) {
     if ($this->geos()) {
       return geoPHP::geosToGeometry($this->geos()->buffer($distance));
     }
   }
 
+  /**
+   *
+   */
   public function intersection(Geometry $geometry) {
     if ($this->geos()) {
       return geoPHP::geosToGeometry($this->geos()->intersection($geometry->geos()));
     }
   }
 
+  /**
+   *
+   */
   public function convexHull() {
     if ($this->geos()) {
       return geoPHP::geosToGeometry($this->geos()->convexHull());
     }
   }
 
+  /**
+   *
+   */
   public function difference(Geometry $geometry) {
     if ($this->geos()) {
       return geoPHP::geosToGeometry($this->geos()->difference($geometry->geos()));
     }
   }
 
+  /**
+   *
+   */
   public function symDifference(Geometry $geometry) {
     if ($this->geos()) {
       return geoPHP::geosToGeometry($this->geos()->symDifference($geometry->geos()));
     }
   }
 
-  // Can pass in a geometry or an array of geometries
+  /**
+   * Can pass in a geometry or an array of geometries.
+   */
   public function union(Geometry $geometry) {
     if ($this->geos()) {
       if (is_array($geometry)) {
@@ -234,113 +427,170 @@ abstract class Geometry
     }
   }
 
+  /**
+   *
+   */
   public function simplify($tolerance, $preserveTopology = FALSE) {
     if ($this->geos()) {
       return geoPHP::geosToGeometry($this->geos()->simplify($tolerance, $preserveTopology));
     }
   }
 
+  /**
+   *
+   */
   public function disjoint(Geometry $geometry) {
     if ($this->geos()) {
       return $this->geos()->disjoint($geometry->geos());
     }
   }
 
+  /**
+   *
+   */
   public function touches(Geometry $geometry) {
     if ($this->geos()) {
       return $this->geos()->touches($geometry->geos());
     }
   }
 
+  /**
+   *
+   */
   public function intersects(Geometry $geometry) {
     if ($this->geos()) {
       return $this->geos()->intersects($geometry->geos());
     }
   }
 
+  /**
+   *
+   */
   public function crosses(Geometry $geometry) {
     if ($this->geos()) {
       return $this->geos()->crosses($geometry->geos());
     }
   }
 
+  /**
+   *
+   */
   public function within(Geometry $geometry) {
     if ($this->geos()) {
       return $this->geos()->within($geometry->geos());
     }
   }
 
+  /**
+   *
+   */
   public function contains(Geometry $geometry) {
     if ($this->geos()) {
       return $this->geos()->contains($geometry->geos());
     }
   }
 
+  /**
+   *
+   */
   public function overlaps(Geometry $geometry) {
     if ($this->geos()) {
       return $this->geos()->overlaps($geometry->geos());
     }
   }
 
+  /**
+   *
+   */
   public function covers(Geometry $geometry) {
     if ($this->geos()) {
       return $this->geos()->covers($geometry->geos());
     }
   }
 
+  /**
+   *
+   */
   public function coveredBy(Geometry $geometry) {
     if ($this->geos()) {
       return $this->geos()->coveredBy($geometry->geos());
     }
   }
 
+  /**
+   *
+   */
   public function distance(Geometry $geometry) {
     if ($this->geos()) {
       return $this->geos()->distance($geometry->geos());
     }
   }
 
+  /**
+   *
+   */
   public function hausdorffDistance(Geometry $geometry) {
     if ($this->geos()) {
       return $this->geos()->hausdorffDistance($geometry->geos());
     }
   }
 
+  /**
+   *
+   */
   public function project(Geometry $point, $normalized = NULL) {
     if ($this->geos()) {
       return $this->geos()->project($point->geos(), $normalized);
     }
   }
 
-  // Public - Placeholders
-  // ---------------------
+  // Public - Placeholders.
+
+  /**
+   * ---------------------.
+   */
   public function hasZ() {
-    // geoPHP does not support Z values at the moment
+    // geoPHP does not support Z values at the moment.
     return FALSE;
   }
 
+  /**
+   *
+   */
   public function is3D() {
-    // geoPHP does not support 3D geometries at the moment
+    // geoPHP does not support 3D geometries at the moment.
     return FALSE;
   }
 
+  /**
+   *
+   */
   public function isMeasured() {
-    // geoPHP does not yet support M values
+    // geoPHP does not yet support M values.
     return FALSE;
   }
 
+  /**
+   *
+   */
   public function coordinateDimension() {
-    // geoPHP only supports 2-dimentional space
+    // geoPHP only supports 2-dimentional space.
     return 2;
   }
 
+  /**
+   *
+   */
   public function z() {
-    // geoPHP only supports 2-dimentional space
+    // geoPHP only supports 2-dimentional space.
     return NULL;
   }
 
+  /**
+   *
+   */
   public function m() {
-    // geoPHP only supports 2-dimentional space
+    // geoPHP only supports 2-dimentional space.
     return NULL;
   }
 
diff --git a/geoPHP/lib/geometry/GeometryCollection.class.php b/geoPHP/lib/geometry/GeometryCollection.class.php
index 4d71119..3a50333 100755
--- a/geoPHP/lib/geometry/GeometryCollection.class.php
+++ b/geoPHP/lib/geometry/GeometryCollection.class.php
@@ -1,29 +1,42 @@
 <?php
+
 /**
- * GeometryCollection: A heterogenous collection of geometries  
+ * GeometryCollection: A heterogenous collection of geometries  .
  */
-class GeometryCollection extends Collection 
-{
+class GeometryCollection extends Collection {
   protected $geom_type = 'GeometryCollection';
-  
+
   // We need to override asArray. Because geometryCollections are heterogeneous
   // we need to specify which type of geometries they contain. We need to do this
   // because, for example, there would be no way to tell the difference between a
-  // MultiPoint or a LineString, since they share the same structure (collection
-  // of points). So we need to call out the type explicitly. 
+  // MultiPoint or a LineString, since they share the same structure (collection.
+
+  /**
+   * Of points). So we need to call out the type explicitly.
+   */
   public function asArray() {
-    $array = array();
+    $array = [];
     foreach ($this->components as $component) {
-      $array[] = array(
+      $array[] = [
         'type' => $component->geometryType(),
         'components' => $component->asArray(),
-      );
+      ];
     }
     return $array;
   }
-  
-  // Not valid for this geomettry
-  public function boundary() { return NULL; }
-  public function isSimple() { return NULL; }
-}
 
+  /**
+   * Not valid for this geomettry.
+   */
+  public function boundary() {
+    return NULL;
+  }
+
+  /**
+   *
+   */
+  public function isSimple() {
+    return NULL;
+  }
+
+}
diff --git a/geoPHP/lib/geometry/LineString.class.php b/geoPHP/lib/geometry/LineString.class.php
index bef082c..897eb4d 100755
--- a/geoPHP/lib/geometry/LineString.class.php
+++ b/geoPHP/lib/geometry/LineString.class.php
@@ -1,66 +1,98 @@
 <?php
+
 /**
  * LineString. A collection of Points representing a line.
  * A line can have more than one segment.
  */
-class LineString extends Collection
-{
+class LineString extends Collection {
   protected $geom_type = 'LineString';
 
   /**
-   * Constructor
+   * Constructor.
    *
-   * @param array $points An array of at least two points with
-   * which to build the LineString
+   * @param array $points
+   *   An array of at least two points with
+   *   which to build the LineString.
    */
-  public function __construct($points = array()) {
+  public function __construct($points = []) {
     if (count($points) == 1) {
       throw new Exception("Cannot construct a LineString with a single point");
     }
 
-    // Call the Collection constructor to build the LineString
+    // Call the Collection constructor to build the LineString.
     parent::__construct($points);
   }
 
-  // The boundary of a linestring is itself
+  /**
+   * The boundary of a linestring is itself.
+   */
   public function boundary() {
     return $this;
   }
 
+  /**
+   *
+   */
   public function startPoint() {
     return $this->pointN(1);
   }
 
+  /**
+   *
+   */
   public function endPoint() {
     $last_n = $this->numPoints();
     return $this->pointN($last_n);
   }
 
+  /**
+   *
+   */
   public function isClosed() {
     return ($this->startPoint()->equals($this->endPoint()));
   }
 
+  /**
+   *
+   */
   public function isRing() {
     return ($this->isClosed() && $this->isSimple());
   }
 
+  /**
+   *
+   */
   public function numPoints() {
     return $this->numGeometries();
   }
 
+  /**
+   *
+   */
   public function pointN($n) {
     return $this->geometryN($n);
   }
 
+  /**
+   *
+   */
   public function dimension() {
-    if ($this->isEmpty()) return 0;
+    if ($this->isEmpty()) {
+      return 0;
+    }
     return 1;
   }
 
+  /**
+   *
+   */
   public function area() {
     return 0;
   }
 
+  /**
+   *
+   */
   public function length() {
     if ($this->geos()) {
       return $this->geos()->length();
@@ -69,20 +101,25 @@ class LineString extends Collection
     foreach ($this->getPoints() as $delta => $point) {
       $previous_point = $this->geometryN($delta);
       if ($previous_point) {
-        $length += sqrt(pow(($previous_point->getX() - $point->getX()), 2) + pow(($previous_point->getY()- $point->getY()), 2));
+        $length += sqrt(pow(($previous_point->getX() - $point->getX()), 2) + pow(($previous_point->getY() - $point->getY()), 2));
       }
     }
     return $length;
   }
 
+  /**
+   *
+   */
   public function greatCircleLength($radius = 6378137) {
     $length = 0;
     $points = $this->getPoints();
-    for($i=0; $i<$this->numPoints()-1; $i++) {
+    for ($i = 0; $i < $this->numPoints() - 1; $i++) {
       $point = $points[$i];
-      $next_point = $points[$i+1];
-      if (!is_object($next_point)) {continue;}
-      // Great circle method
+      $next_point = $points[$i + 1];
+      if (!is_object($next_point)) {
+        continue;
+      }
+      // Great circle method.
       $lat1 = deg2rad($point->getY());
       $lat2 = deg2rad($next_point->getY());
       $lon1 = deg2rad($point->getX());
@@ -94,8 +131,8 @@ class LineString extends Collection
             sqrt(
               pow(cos($lat2) * sin($dlon), 2) +
                 pow(cos($lat1) * sin($lat2) - sin($lat1) * cos($lat2) * cos($dlon), 2)
-            )
-            ,
+            ),
+
             sin($lat1) * sin($lat2) +
               cos($lat1) * cos($lat2) * cos($dlon)
           );
@@ -104,13 +141,18 @@ class LineString extends Collection
     return $length;
   }
 
+  /**
+   *
+   */
   public function haversineLength() {
     $degrees = 0;
     $points = $this->getPoints();
-    for($i=0; $i<$this->numPoints()-1; $i++) {
+    for ($i = 0; $i < $this->numPoints() - 1; $i++) {
       $point = $points[$i];
-      $next_point = $points[$i+1];
-      if (!is_object($next_point)) {continue;}
+      $next_point = $points[$i + 1];
+      if (!is_object($next_point)) {
+        continue;
+      }
       $degree = rad2deg(
         acos(
           sin(deg2rad($point->getY())) * sin(deg2rad($next_point->getY())) +
@@ -120,22 +162,28 @@ class LineString extends Collection
       );
       $degrees += $degree;
     }
-    // Returns degrees
+    // Returns degrees.
     return $degrees;
   }
 
+  /**
+   *
+   */
   public function explode() {
-    $parts = array();
+    $parts = [];
     $points = $this->getPoints();
 
     foreach ($points as $i => $point) {
-      if (isset($points[$i+1])) {
-        $parts[] = new LineString(array($point, $points[$i+1]));
+      if (isset($points[$i + 1])) {
+        $parts[] = new LineString([$point, $points[$i + 1]]);
       }
     }
     return $parts;
   }
 
+  /**
+   *
+   */
   public function isSimple() {
     if ($this->geos()) {
       return $this->geos()->isSimple();
@@ -155,8 +203,11 @@ class LineString extends Collection
     return TRUE;
   }
 
-  // Utility function to check if any line sigments intersect
-  // Derived from http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect
+  // Utility function to check if any line sigments intersect.
+
+  /**
+   * Derived from http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect.
+   */
   public function lineSegmentIntersect($segment) {
     $p0_x = $this->startPoint()->x();
     $p0_y = $this->startPoint()->y();
@@ -178,13 +229,13 @@ class LineString extends Collection
     }
 
     $s = (-$s1_y * ($p0_x - $p2_x) + $s1_x * ($p0_y - $p2_y)) / $fps;
-    $t = ( $s2_x * ($p0_y - $p2_y) - $s2_y * ($p0_x - $p2_x)) / $fpt;
+    $t = ($s2_x * ($p0_y - $p2_y) - $s2_y * ($p0_x - $p2_x)) / $fpt;
 
     if ($s > 0 && $s < 1 && $t > 0 && $t < 1) {
-      // Collision detected
+      // Collision detected.
       return TRUE;
     }
     return FALSE;
   }
-}
 
+}
diff --git a/geoPHP/lib/geometry/MultiLineString.class.php b/geoPHP/lib/geometry/MultiLineString.class.php
index 3ab085a..619115a 100755
--- a/geoPHP/lib/geometry/MultiLineString.class.php
+++ b/geoPHP/lib/geometry/MultiLineString.class.php
@@ -1,12 +1,14 @@
 <?php
+
 /**
- * MultiLineString: A collection of LineStrings
+ * MultiLineString: A collection of LineStrings.
  */
-class MultiLineString extends Collection
-{
+class MultiLineString extends Collection {
   protected $geom_type = 'MultiLineString';
 
-  // MultiLineString is closed if all it's components are closed
+  /**
+   * MultiLineString is closed if all it's components are closed.
+   */
   public function isClosed() {
     foreach ($this->components as $line) {
       if (!$line->isClosed()) {
@@ -17,4 +19,3 @@ class MultiLineString extends Collection
   }
 
 }
-
diff --git a/geoPHP/lib/geometry/MultiPoint.class.php b/geoPHP/lib/geometry/MultiPoint.class.php
index 5b52736..ae97ce3 100755
--- a/geoPHP/lib/geometry/MultiPoint.class.php
+++ b/geoPHP/lib/geometry/MultiPoint.class.php
@@ -1,21 +1,32 @@
 <?php
+
 /**
- * MultiPoint: A collection Points  
+ * MultiPoint: A collection Points  .
  */
-class MultiPoint extends Collection
-{
+class MultiPoint extends Collection {
   protected $geom_type = 'MultiPoint';
-  
+
+  /**
+   *
+   */
   public function numPoints() {
     return $this->numGeometries();
   }
-  
+
+  /**
+   *
+   */
   public function isSimple() {
     return TRUE;
   }
-  
-  // Not valid for this geometry type
-  // --------------------------------
-  public function explode() { return NULL; }
-}
 
+  // Not valid for this geometry type.
+
+  /**
+   * --------------------------------.
+   */
+  public function explode() {
+    return NULL;
+  }
+
+}
diff --git a/geoPHP/lib/geometry/MultiPolygon.class.php b/geoPHP/lib/geometry/MultiPolygon.class.php
index c0fdbe0..be1fba7 100755
--- a/geoPHP/lib/geometry/MultiPolygon.class.php
+++ b/geoPHP/lib/geometry/MultiPolygon.class.php
@@ -1,8 +1,9 @@
 <?php
+
 /**
- * MultiPolygon: A collection of Polygons
+ * MultiPolygon: A collection of Polygons.
  */
-class MultiPolygon extends Collection 
-{
+class MultiPolygon extends Collection {
   protected $geom_type = 'MultiPolygon';
+
 }
diff --git a/geoPHP/lib/geometry/Point.class.php b/geoPHP/lib/geometry/Point.class.php
index f49771e..bb9ecba 100755
--- a/geoPHP/lib/geometry/Point.class.php
+++ b/geoPHP/lib/geometry/Point.class.php
@@ -4,29 +4,31 @@
  * Point: The most basic geometry type. All other geometries
  * are built out of Points.
  */
-class Point extends Geometry
-{
-  public $coords = array(2);
+class Point extends Geometry {
+  public $coords = [2];
   protected $geom_type = 'Point';
   protected $dimention = 2;
 
   /**
-   * Constructor
+   * Constructor.
    *
-   * @param numeric $x The x coordinate (or longitude)
-   * @param numeric $y The y coordinate (or latitude)
-   * @param numeric $z The z coordinate (or altitude) - optional
+   * @param numeric $x
+   *   The x coordinate (or longitude)
+   * @param numeric $y
+   *   The y coordinate (or latitude)
+   * @param numeric $z
+   *   The z coordinate (or altitude) - optional.
    */
   public function __construct($x, $y, $z = NULL) {
-    // Basic validation on x and y
+    // Basic validation on x and y.
     if (!is_numeric($x) || !is_numeric($y)) {
       throw new Exception("Cannot construct Point. x and y should be numeric");
     }
 
-    // Check to see if this is a 3D point
+    // Check to see if this is a 3D point.
     if ($z !== NULL) {
       if (!is_numeric($z)) {
-       throw new Exception("Cannot construct Point. z should be numeric");
+        throw new Exception("Cannot construct Point. z should be numeric");
       }
       $this->dimention = 3;
     }
@@ -36,17 +38,17 @@ class Point extends Geometry
     $y = floatval($y);
     $z = floatval($z);
 
-    // Add poitional elements
+    // Add poitional elements.
     if ($this->dimention == 2) {
-      $this->coords = array($x, $y);
+      $this->coords = [$x, $y];
     }
     if ($this->dimention == 3) {
-      $this->coords = array($x, $y, $z);
+      $this->coords = [$x, $y, $z];
     }
   }
 
   /**
-   * Get X (longitude) coordinate
+   * Get X (longitude) coordinate.
    *
    * @return float The X coordinate
    */
@@ -55,7 +57,7 @@ class Point extends Geometry
   }
 
   /**
-   * Returns Y (latitude) coordinate
+   * Returns Y (latitude) coordinate.
    *
    * @return float The Y coordinate
    */
@@ -64,7 +66,7 @@ class Point extends Geometry
   }
 
   /**
-   * Returns Z (altitude) coordinate
+   * Returns Z (altitude) coordinate.
    *
    * @return float The Z coordinate or NULL is not a 3D point
    */
@@ -72,84 +74,196 @@ class Point extends Geometry
     if ($this->dimention == 3) {
       return $this->coords[2];
     }
-    else return NULL;
+    else {
+      return NULL;
+    }
   }
 
-  // A point's centroid is itself
+  /**
+   * A point's centroid is itself.
+   */
   public function centroid() {
     return $this;
   }
 
+  /**
+   *
+   */
   public function getBBox() {
-    return array(
+    return [
       'maxy' => $this->getY(),
       'miny' => $this->getY(),
       'maxx' => $this->getX(),
       'minx' => $this->getX(),
-    );
+    ];
   }
 
+  /**
+   *
+   */
   public function asArray($assoc = FALSE) {
     return $this->coords;
   }
 
+  /**
+   *
+   */
   public function area() {
     return 0;
   }
 
+  /**
+   *
+   */
   public function length() {
     return 0;
   }
 
+  /**
+   *
+   */
   public function greatCircleLength() {
     return 0;
   }
 
+  /**
+   *
+   */
   public function haversineLength() {
     return 0;
   }
 
-  // The boundary of a point is itself
+  /**
+   * The boundary of a point is itself.
+   */
   public function boundary() {
     return $this;
   }
 
+  /**
+   *
+   */
   public function dimension() {
     return 0;
   }
 
+  /**
+   *
+   */
   public function isEmpty() {
     return FALSE;
   }
 
+  /**
+   *
+   */
   public function numPoints() {
     return 1;
   }
 
+  /**
+   *
+   */
   public function getPoints() {
-    return array($this);
+    return [$this];
   }
 
+  /**
+   *
+   */
   public function equals($geometry) {
     return ($this->x() == $geometry->x() && $this->y() == $geometry->y());
   }
 
+  /**
+   *
+   */
   public function isSimple() {
     return TRUE;
   }
 
-  // Not valid for this geometry type
-  public function numGeometries()    { return NULL; }
-  public function geometryN($n)      { return NULL; }
-  public function startPoint()       { return NULL; }
-  public function endPoint()         { return NULL; }
-  public function isRing()           { return NULL; }
-  public function isClosed()         { return NULL; }
-  public function pointN($n)         { return NULL; }
-  public function exteriorRing()     { return NULL; }
-  public function numInteriorRings() { return NULL; }
-  public function interiorRingN($n)  { return NULL; }
-  public function pointOnSurface()   { return NULL; }
-  public function explode()          { return NULL; }
-}
+  /**
+   * Not valid for this geometry type.
+   */
+  public function numGeometries() {
+    return NULL;
+  }
 
+  /**
+   *
+   */
+  public function geometryN($n) {
+    return NULL;
+  }
+
+  /**
+   *
+   */
+  public function startPoint() {
+    return NULL;
+  }
+
+  /**
+   *
+   */
+  public function endPoint() {
+    return NULL;
+  }
+
+  /**
+   *
+   */
+  public function isRing() {
+    return NULL;
+  }
+
+  /**
+   *
+   */
+  public function isClosed() {
+    return NULL;
+  }
+
+  /**
+   *
+   */
+  public function pointN($n) {
+    return NULL;
+  }
+
+  /**
+   *
+   */
+  public function exteriorRing() {
+    return NULL;
+  }
+
+  /**
+   *
+   */
+  public function numInteriorRings() {
+    return NULL;
+  }
+
+  /**
+   *
+   */
+  public function interiorRingN($n) {
+    return NULL;
+  }
+
+  /**
+   *
+   */
+  public function pointOnSurface() {
+    return NULL;
+  }
+
+  /**
+   *
+   */
+  public function explode() {
+    return NULL;
+  }
+
+}
diff --git a/geoPHP/lib/geometry/Polygon.class.php b/geoPHP/lib/geometry/Polygon.class.php
index 15c060b..83dcb98 100755
--- a/geoPHP/lib/geometry/Polygon.class.php
+++ b/geoPHP/lib/geometry/Polygon.class.php
@@ -1,128 +1,166 @@
 <?php
 
 /**
- * Polygon: A polygon is a plane figure that is bounded by a closed path, 
- * composed of a finite sequence of straight line segments
+ * Polygon: A polygon is a plane figure that is bounded by a closed path,
+ * composed of a finite sequence of straight line segments.
  */
-class Polygon extends Collection
-{
+class Polygon extends Collection {
   protected $geom_type = 'Polygon';
-  
+
+  /**
+   *
+   */
   public function area($exterior_only = FALSE, $signed = FALSE) {
-    if ($this->isEmpty()) return 0;
-    
+    if ($this->isEmpty()) {
+      return 0;
+    }
+
     if ($this->geos() && $exterior_only == FALSE) {
       return $this->geos()->area();
     }
-    
+
     $exterior_ring = $this->components[0];
     $pts = $exterior_ring->getComponents();
-    
+
     $c = count($pts);
-    if((int)$c == '0') return NULL;
+    if ((int) $c == '0') {
+      return NULL;
+    }
     $a = '0';
-    foreach($pts as $k => $p){
+    foreach ($pts as $k => $p) {
       $j = ($k + 1) % $c;
       $a = $a + ($p->getX() * $pts[$j]->getY()) - ($p->getY() * $pts[$j]->getX());
     }
-    
-    if ($signed) $area = ($a / 2);
-    else $area = abs(($a / 2));
-    
+
+    if ($signed) {
+      $area = ($a / 2);
+    }
+    else {
+      $area = abs(($a / 2));
+    }
+
     if ($exterior_only == TRUE) {
       return $area;
     }
     foreach ($this->components as $delta => $component) {
       if ($delta != 0) {
-        $inner_poly = new Polygon(array($component));
+        $inner_poly = new Polygon([$component]);
         $area -= $inner_poly->area();
       }
     }
     return $area;
   }
-  
+
+  /**
+   *
+   */
   public function centroid() {
-    if ($this->isEmpty()) return NULL;
-    
+    if ($this->isEmpty()) {
+      return NULL;
+    }
+
     if ($this->geos()) {
       return geoPHP::geosToGeometry($this->geos()->centroid());
     }
-    
+
     $exterior_ring = $this->components[0];
     $pts = $exterior_ring->getComponents();
-    
+
     $c = count($pts);
-    if((int)$c == '0') return NULL;
-    $cn = array('x' => '0', 'y' => '0');
+    if ((int) $c == '0') {
+      return NULL;
+    }
+    $cn = ['x' => '0', 'y' => '0'];
     $a = $this->area(TRUE, TRUE);
-    
+
     // If this is a polygon with no area. Just return the first point.
     if ($a == 0) {
       return $this->exteriorRing()->pointN(1);
     }
-    
-    foreach($pts as $k => $p){
+
+    foreach ($pts as $k => $p) {
       $j = ($k + 1) % $c;
       $P = ($p->getX() * $pts[$j]->getY()) - ($p->getY() * $pts[$j]->getX());
       $cn['x'] = $cn['x'] + ($p->getX() + $pts[$j]->getX()) * $P;
       $cn['y'] = $cn['y'] + ($p->getY() + $pts[$j]->getY()) * $P;
     }
-    
-    $cn['x'] = $cn['x'] / ( 6 * $a);
-    $cn['y'] = $cn['y'] / ( 6 * $a);
-    
+
+    $cn['x'] = $cn['x'] / (6 * $a);
+    $cn['y'] = $cn['y'] / (6 * $a);
+
     $centroid = new Point($cn['x'], $cn['y']);
     return $centroid;
   }
 
-	/**
-	 * Find the outermost point from the centroid
-	 *
-	 * @returns Point The outermost point
-	 */
+  /**
+   * Find the outermost point from the centroid.
+   *
+   * @returns Point The outermost point
+   */
   public function outermostPoint() {
-		$centroid = $this->getCentroid();
+    $centroid = $this->getCentroid();
 
-		$max = array('length' => 0, 'point' => null);
+    $max = ['length' => 0, 'point' => NULL];
 
-		foreach($this->getPoints() as $point) {
-			$lineString = new LineString(array($centroid, $point));
+    foreach ($this->getPoints() as $point) {
+      $lineString = new LineString([$centroid, $point]);
 
-			if($lineString->length() > $max['length']) {
-				$max['length'] = $lineString->length();
-				$max['point'] = $point;
-			}
-		}
+      if ($lineString->length() > $max['length']) {
+        $max['length'] = $lineString->length();
+        $max['point'] = $point;
+      }
+    }
 
-		return $max['point'];
+    return $max['point'];
   }
 
+  /**
+   *
+   */
   public function exteriorRing() {
-    if ($this->isEmpty()) return new LineString();
+    if ($this->isEmpty()) {
+      return new LineString();
+    }
     return $this->components[0];
   }
-  
+
+  /**
+   *
+   */
   public function numInteriorRings() {
-    if ($this->isEmpty()) return 0;
-    return $this->numGeometries()-1;
+    if ($this->isEmpty()) {
+      return 0;
+    }
+    return $this->numGeometries() - 1;
   }
-  
+
+  /**
+   *
+   */
   public function interiorRingN($n) {
-    return $this->geometryN($n+1);
+    return $this->geometryN($n + 1);
   }
-  
+
+  /**
+   *
+   */
   public function dimension() {
-    if ($this->isEmpty()) return 0;
+    if ($this->isEmpty()) {
+      return 0;
+    }
     return 2;
   }
 
+  /**
+   *
+   */
   public function isSimple() {
     if ($this->geos()) {
       return $this->geos()->isSimple();
     }
-    
+
     $segments = $this->explode();
-    
+
     foreach ($segments as $i => $segment) {
       foreach ($segments as $j => $check_segment) {
         if ($i != $j) {
@@ -135,9 +173,13 @@ class Polygon extends Collection
     return TRUE;
   }
 
-  // Not valid for this geometry type
-  // --------------------------------
-  public function length() { return NULL; }
-  
-}
+  // Not valid for this geometry type.
+
+  /**
+   * --------------------------------.
+   */
+  public function length() {
+    return NULL;
+  }
 
+}
diff --git a/geoPHP/tests/postgis.php b/geoPHP/tests/postgis.php
index c231858..564fdc1 100755
--- a/geoPHP/tests/postgis.php
+++ b/geoPHP/tests/postgis.php
@@ -1,36 +1,41 @@
-<?
-// Uncomment to test
-# run_test();
+<?php
 
+/**
+ * @file
+ * Uncomment to test.
+ */
+
+/**
+ * Run_test();.
+ */
 function run_test() {
 
   header("Content-type: text");
-  
-  include_once('../geoPHP.inc');
-  
+
+  include_once '../geoPHP.inc';
+
   // Your database test table should contain 3 columns: name (text), type (text), geom (geometry)
-  $host =     'localhost';
+  $host = 'localhost';
   $database = 'phayes';
-  $table =    'test';
-  $column =   'geom';
-  $user =     'phayes';
-  $pass =     'supersecret';
-  
+  $table = 'test';
+  $column = 'geom';
+  $user = 'phayes';
+  $pass = 'supersecret';
+
   $connection = pg_connect("host=$host dbname=$database user=$user password=$pass");
-  
-  // Truncate
+
+  // Truncate.
   pg_query($connection, "DELETE FROM $table");
-  
+
   // Working with PostGIS and EWKB
-  // ----------------------------
-  
+  // ----------------------------.
   foreach (scandir('./input') as $file) {
-    $parts = explode('.',$file);
+    $parts = explode('.', $file);
     if ($parts[0]) {
       $name = $parts[0];
       $format = $parts[1];
-      $value = file_get_contents('./input/'.$file);
-      print '---- Testing '.$file."\n";
+      $value = file_get_contents('./input/' . $file);
+      print '---- Testing ' . $file . "\n";
       flush();
       $geometry = geoPHP::load($value, $format);
       test_postgis($name, $format, $geometry, $connection, 'wkb');
@@ -41,28 +46,35 @@ function run_test() {
   print "Testing Done!";
 }
 
+/**
+ *
+ */
 function test_postgis($name, $type, $geom, $connection, $format) {
   global $table;
-  
-  // Let's insert into the database using GeomFromWKB
+
+  // Let's insert into the database using GeomFromWKB.
   $insert_string = pg_escape_bytea($geom->out($format));
   pg_query($connection, "INSERT INTO $table (name, type, geom) values ('$name', '$type', GeomFromWKB('$insert_string'))");
-  
-  // SELECT using asBinary PostGIS
+
+  // SELECT using asBinary PostGIS.
   $result = pg_fetch_all(pg_query($connection, "SELECT asBinary(geom) as geom FROM $table WHERE name='$name'"));
   foreach ($result as $item) {
-    $wkb = pg_unescape_bytea($item['geom']); // Make sure to unescape the hex blob
-    $geom = geoPHP::load($wkb, $format); // We now a full geoPHP Geometry object
+    // Make sure to unescape the hex blob.
+    $wkb = pg_unescape_bytea($item['geom']);
+    // We now a full geoPHP Geometry object.
+    $geom = geoPHP::load($wkb, $format);
   }
-  
-  // SELECT and INSERT directly, with no wrapping functions
+
+  // SELECT and INSERT directly, with no wrapping functions.
   $result = pg_fetch_all(pg_query($connection, "SELECT geom as geom FROM $table WHERE name='$name'"));
   foreach ($result as $item) {
-    $wkb = pack('H*',$item['geom']);   // Unpacking the hex blob
-    $geom = geoPHP::load($wkb, $format); // We now have a geoPHP Geometry
-  
+    // Unpacking the hex blob.
+    $wkb = pack('H*', $item['geom']);
+    // We now have a geoPHP Geometry.
+    $geom = geoPHP::load($wkb, $format);
+
     // Let's re-insert directly into postGIS
-    // We need to unpack the WKB
+    // We need to unpack the WKB.
     $unpacked = unpack('H*', $geom->out($format));
     $insert_string = $unpacked[1];
     pg_query($connection, "INSERT INTO $table (name, type, geom) values ('$name', '$type', '$insert_string')");
@@ -71,12 +83,13 @@ function test_postgis($name, $type, $geom, $connection, $format) {
   // SELECT and INSERT using as EWKT (ST_GeomFromEWKT and ST_AsEWKT)
   $result = pg_fetch_all(pg_query($connection, "SELECT ST_AsEWKT(geom) as geom FROM $table WHERE name='$name'"));
   foreach ($result as $item) {
-    $wkt = $item['geom']; // Make sure to unescape the hex blob
-    $geom = geoPHP::load($wkt, 'ewkt'); // We now a full geoPHP Geometry object
+    // Make sure to unescape the hex blob.
+    $wkt = $item['geom'];
+    // We now a full geoPHP Geometry object.
+    $geom = geoPHP::load($wkt, 'ewkt');
 
-    // Let's re-insert directly into postGIS
+    // Let's re-insert directly into postGIS.
     $insert_string = $geom->out('ewkt');
     pg_query($connection, "INSERT INTO $table (name, type, geom) values ('$name', '$type', ST_GeomFromEWKT('$insert_string'))");
   }
 }
-
diff --git a/geoPHP/tests/test.php b/geoPHP/tests/test.php
index d2259a0..699d9f9 100755
--- a/geoPHP/tests/test.php
+++ b/geoPHP/tests/test.php
@@ -1,14 +1,19 @@
 <?php
 
-// Uncomment to test
-# run_test();
-
+/**
+ * @file
+ * Uncomment to test.
+ */
+
+/**
+ * Run_test();.
+ */
 function run_test() {
   set_time_limit(0);
 
   header("Content-type: text");
 
-  include_once('../geoPHP.inc');
+  include_once '../geoPHP.inc';
 
   if (geoPHP::geosInstalled()) {
     print "GEOS is installed.\n";
@@ -18,11 +23,11 @@ function run_test() {
   }
 
   foreach (scandir('./input') as $file) {
-    $parts = explode('.',$file);
+    $parts = explode('.', $file);
     if ($parts[0]) {
       $format = $parts[1];
-      $value = file_get_contents('./input/'.$file);
-      print '---- Testing '.$file."\n";
+      $value = file_get_contents('./input/' . $file);
+      print '---- Testing ' . $file . "\n";
       $geometry = geoPHP::load($value, $format);
       test_adapters($geometry, $format, $value);
       test_methods($geometry);
@@ -33,9 +38,12 @@ function run_test() {
   print "Testing Done!";
 }
 
+/**
+ *
+ */
 function test_geometry($geometry) {
 
-  // Test common functions
+  // Test common functions.
   $geometry->area();
   $geometry->boundary();
   $geometry->envelope();
@@ -62,7 +70,7 @@ function test_geometry($geometry) {
   $geometry->SRID();
   $geometry->setSRID(4326);
 
-  // Aliases
+  // Aliases.
   $geometry->getCentroid();
   $geometry->getArea();
   $geometry->getX();
@@ -73,7 +81,7 @@ function test_geometry($geometry) {
   $geometry->asText();
   $geometry->asBinary();
 
-  // GEOS only functions
+  // GEOS only functions.
   $geometry->geos();
   $geometry->setGeos($geometry->geos());
   $geometry->pointOnSurface();
@@ -88,7 +96,8 @@ function test_geometry($geometry) {
   $geometry->difference($geometry);
   $geometry->symDifference($geometry);
   $geometry->union($geometry);
-  $geometry->simplify(0);// @@TODO: Adjust this once we can deal with empty geometries
+  // @@TODO: Adjust this once we can deal with empty geometries
+  $geometry->simplify(0);
   $geometry->disjoint($geometry);
   $geometry->touches($geometry);
   $geometry->intersects($geometry);
@@ -101,8 +110,7 @@ function test_geometry($geometry) {
   $geometry->distance($geometry);
   $geometry->hausdorffDistance($geometry);
 
-
-  // Place holders
+  // Place holders.
   $geometry->hasZ();
   $geometry->is3D();
   $geometry->isMeasured();
@@ -112,10 +120,14 @@ function test_geometry($geometry) {
   $geometry->m();
 }
 
+/**
+ *
+ */
 function test_adapters($geometry, $format, $input) {
-  // Test adapter output and input. Do a round-trip and re-test
+  // Test adapter output and input. Do a round-trip and re-test.
   foreach (geoPHP::getAdapterMap() as $adapter_key => $adapter_class) {
-    if ($adapter_key != 'google_geocode') { //Don't test google geocoder regularily. Uncomment to test
+    // Don't test google geocoder regularily. Uncomment to test.
+    if ($adapter_key != 'google_geocode') {
       $output = $geometry->out($adapter_key);
       if ($output) {
         $adapter_loader = new $adapter_class();
@@ -123,22 +135,25 @@ function test_adapters($geometry, $format, $input) {
         $test_geom_2 = $adapter_loader->read($test_geom_1->out($adapter_key));
 
         if ($test_geom_1->out('wkt') != $test_geom_2->out('wkt')) {
-          print "Mismatched adapter output in ".$adapter_class."\n";
+          print "Mismatched adapter output in " . $adapter_class . "\n";
         }
       }
       else {
-        print "Empty output on "  . $adapter_key . "\n";
+        print "Empty output on " . $adapter_key . "\n";
       }
     }
   }
 
   // Test to make sure adapter work the same wether GEOS is ON or OFF
-  // Cannot test methods if GEOS is not intstalled
-  if (!geoPHP::geosInstalled()) return;
+  // Cannot test methods if GEOS is not intstalled.
+  if (!geoPHP::geosInstalled()) {
+    return;
+  }
 
   foreach (geoPHP::getAdapterMap() as $adapter_key => $adapter_class) {
-    if ($adapter_key != 'google_geocode') { //Don't test google geocoder regularily. Uncomment to test
-      // Turn GEOS on
+    // Don't test google geocoder regularily. Uncomment to test.
+    if ($adapter_key != 'google_geocode') {
+      // Turn GEOS on.
       geoPHP::geosInstalled(TRUE);
 
       $output = $geometry->out($adapter_key);
@@ -147,31 +162,36 @@ function test_adapters($geometry, $format, $input) {
 
         $test_geom_1 = $adapter_loader->read($output);
 
-        // Turn GEOS off
+        // Turn GEOS off.
         geoPHP::geosInstalled(FALSE);
 
         $test_geom_2 = $adapter_loader->read($output);
 
-        // Turn GEOS back On
+        // Turn GEOS back On.
         geoPHP::geosInstalled(TRUE);
 
-        // Check to make sure a both are the same with geos and without
+        // Check to make sure a both are the same with geos and without.
         if ($test_geom_1->out('wkt') != $test_geom_2->out('wkt')) {
-          print "Mismatched adapter output between GEOS and NORM in ".$adapter_class."\n";
+          print "Mismatched adapter output between GEOS and NORM in " . $adapter_class . "\n";
         }
       }
     }
   }
 }
 
-
+/**
+ *
+ */
 function test_methods($geometry) {
-  // Cannot test methods if GEOS is not intstalled
-  if (!geoPHP::geosInstalled()) return;
+  // Cannot test methods if GEOS is not intstalled.
+  if (!geoPHP::geosInstalled()) {
+    return;
+  }
 
-  $methods = array(
-    //'boundary', //@@TODO: Uncomment this and fix errors
-    'envelope',   //@@TODO: Testing reveales errors in this method -- POINT vs. POLYGON
+  $methods = [
+    // 'boundary', //@@TODO: Uncomment this and fix errors
+  // @@TODO: Testing reveales errors in this method -- POINT vs. POLYGON
+    'envelope',
     'getBBox',
     'x',
     'y',
@@ -180,66 +200,73 @@ function test_methods($geometry) {
     'isRing',
     'isClosed',
     'numPoints',
-  );
+  ];
 
   foreach ($methods as $method) {
-    // Turn GEOS on
+    // Turn GEOS on.
     geoPHP::geosInstalled(TRUE);
     $geos_result = $geometry->$method();
 
-    // Turn GEOS off
+    // Turn GEOS off.
     geoPHP::geosInstalled(FALSE);
     $norm_result = $geometry->$method();
 
-    // Turn GEOS back On
+    // Turn GEOS back On.
     geoPHP::geosInstalled(TRUE);
 
     $geos_type = gettype($geos_result);
     $norm_type = gettype($norm_result);
 
     if ($geos_type != $norm_type) {
-      print 'Type mismatch on '.$method."\n";
+      print 'Type mismatch on ' . $method . "\n";
       continue;
     }
 
-    // Now check base on type
+    // Now check base on type.
     if ($geos_type == 'object') {
-      $haus_dist = $geos_result->hausdorffDistance(geoPHP::load($norm_result->out('wkt'),'wkt'));
+      $haus_dist = $geos_result->hausdorffDistance(geoPHP::load($norm_result->out('wkt'), 'wkt'));
 
       // Get the length of the diagonal of the bbox - this is used to scale the haustorff distance
-      // Using Pythagorean theorem
+      // Using Pythagorean theorem.
       $bb = $geos_result->getBBox();
-      $scale = sqrt((($bb['maxy'] - $bb['miny'])^2) + (($bb['maxx'] - $bb['minx'])^2));
+      $scale = sqrt((($bb['maxy'] - $bb['miny']) ^ 2) + (($bb['maxx'] - $bb['minx']) ^ 2));
 
-      // The difference in the output of GEOS and native-PHP methods should be less than 0.5 scaled haustorff units
+      // The difference in the output of GEOS and native-PHP methods should be less than 0.5 scaled haustorff units.
       if ($haus_dist / $scale > 0.5) {
-        print 'Output mismatch on '.$method.":\n";
-        print 'GEOS : '.$geos_result->out('wkt')."\n";
-        print 'NORM : '.$norm_result->out('wkt')."\n";
+        print 'Output mismatch on ' . $method . ":\n";
+        print 'GEOS : ' . $geos_result->out('wkt') . "\n";
+        print 'NORM : ' . $norm_result->out('wkt') . "\n";
         continue;
       }
     }
 
     if ($geos_type == 'boolean' || $geos_type == 'string') {
       if ($geos_result !== $norm_result) {
-        print 'Output mismatch on '.$method.":\n";
-        print 'GEOS : '.(string) $geos_result."\n";
-        print 'NORM : '.(string) $norm_result."\n";
+        print 'Output mismatch on ' . $method . ":\n";
+        print 'GEOS : ' . (string) $geos_result . "\n";
+        print 'NORM : ' . (string) $norm_result . "\n";
         continue;
       }
     }
 
-    //@@TODO: Run tests for output of types arrays and float
-    //@@TODO: centroid function is non-compliant for collections and strings
+    // @@TODO: Run tests for output of types arrays and float
+    // @@TODO: centroid function is non-compliant for collections and strings
   }
 }
 
+/**
+ *
+ */
 function test_detection($value, $format, $file) {
   $detected = geoPHP::detectFormat($value);
   if ($detected != $format) {
-    if ($detected) print 'detected as ' . $detected . "\n";
-    else print "not detected\n";
+    if ($detected) {
+      print 'detected as ' . $detected . "\n";
+    }
+    else {
+      print "not detected\n";
+    }
   }
-  // Make sure it loads using auto-detect
+  // Make sure it loads using auto-detect.
   geoPHP::load($value);
 }
diff --git a/geoPHP/tests/tests/20120702Test.php b/geoPHP/tests/tests/20120702Test.php
index da056aa..b860c96 100755
--- a/geoPHP/tests/tests/20120702Test.php
+++ b/geoPHP/tests/tests/20120702Test.php
@@ -1,46 +1,55 @@
 <?php
-require_once('../geoPHP.inc');
-require_once('PHPUnit/Autoload.php');
 
+require_once '../geoPHP.inc';
+require_once 'PHPUnit/Autoload.php';
+/**
+ *
+ */
 class Tests_20120702 extends PHPUnit_Framework_TestCase {
 
-  function setUp() {
+  /**
+   *
+   */
+  public function setUp() {
 
   }
 
-  function testMethods() {
+  /**
+   *
+   */
+  public function testMethods() {
     $format = 'gpx';
     $value = file_get_contents('./input/20120702.gpx');
     $geometry = geoPHP::load($value, $format);
 
-    $methods = array(
-      array('name' => 'area'),
-      array('name' => 'boundary'),
-      array('name' => 'getBBox'),
-      array('name' => 'centroid'),
-      array('name' => 'length'),
-      array('name' => 'greatCircleLength', 'argument' => 6378137),
-      array('name' => 'haversineLength'),
-      array('name' => 'y'),
-      array('name' => 'x'),
-      array('name' => 'numGeometries'),
-      array('name' => 'geometryN', 'argument' => '1'),
-      array('name' => 'startPoint'),
-      array('name' => 'endPoint'),
-      array('name' => 'isRing'),
-      array('name' => 'isClosed'),
-      array('name' => 'numPoints'),
-      array('name' => 'pointN', 'argument' => '1'),
-      array('name' => 'exteriorRing'),
-      array('name' => 'numInteriorRings'),
-      array('name' => 'interiorRingN', 'argument' => '1'),
-      array('name' => 'dimension'),
-      array('name' => 'geometryType'),
-      array('name' => 'SRID'),
-      array('name' => 'setSRID', 'argument' => '4326'),
-    );
-
-    foreach($methods as $method) {
+    $methods = [
+      ['name' => 'area'],
+      ['name' => 'boundary'],
+      ['name' => 'getBBox'],
+      ['name' => 'centroid'],
+      ['name' => 'length'],
+      ['name' => 'greatCircleLength', 'argument' => 6378137],
+      ['name' => 'haversineLength'],
+      ['name' => 'y'],
+      ['name' => 'x'],
+      ['name' => 'numGeometries'],
+      ['name' => 'geometryN', 'argument' => '1'],
+      ['name' => 'startPoint'],
+      ['name' => 'endPoint'],
+      ['name' => 'isRing'],
+      ['name' => 'isClosed'],
+      ['name' => 'numPoints'],
+      ['name' => 'pointN', 'argument' => '1'],
+      ['name' => 'exteriorRing'],
+      ['name' => 'numInteriorRings'],
+      ['name' => 'interiorRingN', 'argument' => '1'],
+      ['name' => 'dimension'],
+      ['name' => 'geometryType'],
+      ['name' => 'SRID'],
+      ['name' => 'setSRID', 'argument' => '4326'],
+    ];
+
+    foreach ($methods as $method) {
       $argument = NULL;
       $method_name = $method['name'];
       if (isset($method['argument'])) {
@@ -50,10 +59,13 @@ class Tests_20120702 extends PHPUnit_Framework_TestCase {
     }
   }
 
-  function _methods_tester($geometry, $method_name, $argument) {
+  /**
+   *
+   */
+  public function _methods_tester($geometry, $method_name, $argument) {
 
     if (!method_exists($geometry, $method_name)) {
-      $this->fail("Method ".$method_name.'() doesn\'t exists.');
+      $this->fail("Method " . $method_name . '() doesn\'t exists.');
       return;
     }
 
@@ -70,6 +82,7 @@ class Tests_20120702 extends PHPUnit_Framework_TestCase {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         break;
+
       case 'geometryN':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -81,6 +94,7 @@ class Tests_20120702 extends PHPUnit_Framework_TestCase {
           $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         break;
+
       case 'startPoint':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -89,10 +103,11 @@ class Tests_20120702 extends PHPUnit_Framework_TestCase {
           $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         if ($geometry->geometryType() == 'MultiLineString') {
-          //TODO: Add a method startPoint() to MultiLineString.
-          //$this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
+          // TODO: Add a method startPoint() to MultiLineString.
+          // $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);.
         }
         break;
+
       case 'endPoint':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -101,10 +116,11 @@ class Tests_20120702 extends PHPUnit_Framework_TestCase {
           $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         if ($geometry->geometryType() == 'MultiLineString') {
-          //TODO: Add a method endPoint() to MultiLineString.
-          //$this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
+          // TODO: Add a method endPoint() to MultiLineString.
+          // $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);.
         }
         break;
+
       case 'isRing':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -116,6 +132,7 @@ class Tests_20120702 extends PHPUnit_Framework_TestCase {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         break;
+
       case 'isClosed':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -127,6 +144,7 @@ class Tests_20120702 extends PHPUnit_Framework_TestCase {
           $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         break;
+
       case 'pointN':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -135,10 +153,11 @@ class Tests_20120702 extends PHPUnit_Framework_TestCase {
           $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         if ($geometry->geometryType() == 'MultiLineString') {
-          //TODO: Add a method pointN() to MultiLineString.
-          //$this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
+          // TODO: Add a method pointN() to MultiLineString.
+          // $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);.
         }
         break;
+
       case 'exteriorRing':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -150,6 +169,7 @@ class Tests_20120702 extends PHPUnit_Framework_TestCase {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         break;
+
       case 'numInteriorRings':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -161,6 +181,7 @@ class Tests_20120702 extends PHPUnit_Framework_TestCase {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         break;
+
       case 'interiorRingN':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -172,9 +193,11 @@ class Tests_20120702 extends PHPUnit_Framework_TestCase {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         break;
+
       case 'setSRID':
-        //TODO: The method setSRID() should return TRUE.
+        // TODO: The method setSRID() should return TRUE.
         break;
+
       case 'SRID':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -186,6 +209,7 @@ class Tests_20120702 extends PHPUnit_Framework_TestCase {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         break;
+
       case 'getBBox':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -197,6 +221,7 @@ class Tests_20120702 extends PHPUnit_Framework_TestCase {
           $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         break;
+
       case 'centroid':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -208,6 +233,7 @@ class Tests_20120702 extends PHPUnit_Framework_TestCase {
           $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         break;
+
       case 'length':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -219,6 +245,7 @@ class Tests_20120702 extends PHPUnit_Framework_TestCase {
           $this->assertEquals($geometry->$method_name($argument), (float) '0.11624637315233', 'Failed on ' . $method_name);
         }
         break;
+
       case 'numGeometries':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -230,6 +257,7 @@ class Tests_20120702 extends PHPUnit_Framework_TestCase {
           $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         break;
+
       case 'numPoints':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -241,6 +269,7 @@ class Tests_20120702 extends PHPUnit_Framework_TestCase {
           $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         break;
+
       case 'dimension':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -252,6 +281,7 @@ class Tests_20120702 extends PHPUnit_Framework_TestCase {
           $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         break;
+
       case 'boundary':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -263,6 +293,7 @@ class Tests_20120702 extends PHPUnit_Framework_TestCase {
           $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         break;
+
       case 'greatCircleLength':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -274,16 +305,19 @@ class Tests_20120702 extends PHPUnit_Framework_TestCase {
           $this->assertNotEquals($geometry->$method_name($argument), '9500.9359867418', 'Failed on ' . $method_name);
         }
         break;
+
       case 'haversineLength':
       case 'area':
         $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         break;
+
       case 'geometryType':
         $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         break;
+
       default:
         $this->assertTrue($geometry->$method_name($argument), 'Failed on ' . $method_name);
     }
   }
-}
 
+}
diff --git a/geoPHP/tests/tests/adaptersTest.php b/geoPHP/tests/tests/adaptersTest.php
index e56bf00..a17cf61 100755
--- a/geoPHP/tests/tests/adaptersTest.php
+++ b/geoPHP/tests/tests/adaptersTest.php
@@ -1,42 +1,55 @@
 <?php
-require_once('../geoPHP.inc');
-require_once('PHPUnit/Autoload.php');
 
+require_once '../geoPHP.inc';
+require_once 'PHPUnit/Autoload.php';
+/**
+ *
+ */
 class AdaptersTests extends PHPUnit_Framework_TestCase {
 
-  function setUp() {
+  /**
+   *
+   */
+  public function setUp() {
 
   }
 
-  function testAdapters() {
+  /**
+   *
+   */
+  public function testAdapters() {
     foreach (scandir('./input') as $file) {
-      $parts = explode('.',$file);
+      $parts = explode('.', $file);
       if ($parts[0]) {
         $format = $parts[1];
-        $input = file_get_contents('./input/'.$file);
+        $input = file_get_contents('./input/' . $file);
         $geometry = geoPHP::load($input, $format);
 
-        // Test adapter output and input. Do a round-trip and re-test
+        // Test adapter output and input. Do a round-trip and re-test.
         foreach (geoPHP::getAdapterMap() as $adapter_key => $adapter_class) {
-          if ($adapter_key != 'google_geocode') { //Don't test google geocoder regularily. Uncomment to test
+          // Don't test google geocoder regularily. Uncomment to test.
+          if ($adapter_key != 'google_geocode') {
             $output = $geometry->out($adapter_key);
-            $this->assertNotNull($output, "Empty output on "  . $adapter_key);
+            $this->assertNotNull($output, "Empty output on " . $adapter_key);
             if ($output) {
               $adapter_loader = new $adapter_class();
               $test_geom_1 = $adapter_loader->read($output);
               $test_geom_2 = $adapter_loader->read($test_geom_1->out($adapter_key));
-              $this->assertEquals($test_geom_1->out('wkt'), $test_geom_2->out('wkt'), "Mismatched adapter output in ".$adapter_class);
+              $this->assertEquals($test_geom_1->out('wkt'), $test_geom_2->out('wkt'), "Mismatched adapter output in " . $adapter_class);
             }
           }
         }
 
         // Test to make sure adapter work the same wether GEOS is ON or OFF
-        // Cannot test methods if GEOS is not intstalled
-        if (!geoPHP::geosInstalled()) return;
+        // Cannot test methods if GEOS is not intstalled.
+        if (!geoPHP::geosInstalled()) {
+          return;
+        }
 
         foreach (geoPHP::getAdapterMap() as $adapter_key => $adapter_class) {
-          if ($adapter_key != 'google_geocode') { //Don't test google geocoder regularily. Uncomment to test
-            // Turn GEOS on
+          // Don't test google geocoder regularily. Uncomment to test.
+          if ($adapter_key != 'google_geocode') {
+            // Turn GEOS on.
             geoPHP::geosInstalled(TRUE);
 
             $output = $geometry->out($adapter_key);
@@ -45,20 +58,21 @@ class AdaptersTests extends PHPUnit_Framework_TestCase {
 
               $test_geom_1 = $adapter_loader->read($output);
 
-              // Turn GEOS off
+              // Turn GEOS off.
               geoPHP::geosInstalled(FALSE);
 
               $test_geom_2 = $adapter_loader->read($output);
 
-              // Turn GEOS back On
+              // Turn GEOS back On.
               geoPHP::geosInstalled(TRUE);
 
-              // Check to make sure a both are the same with geos and without
-              $this->assertEquals($test_geom_1->out('wkt'), $test_geom_2->out('wkt'), "Mismatched adapter output between GEOS and NORM in ".$adapter_class);
+              // Check to make sure a both are the same with geos and without.
+              $this->assertEquals($test_geom_1->out('wkt'), $test_geom_2->out('wkt'), "Mismatched adapter output between GEOS and NORM in " . $adapter_class);
             }
           }
         }
       }
     }
   }
+
 }
diff --git a/geoPHP/tests/tests/aliasesTest.php b/geoPHP/tests/tests/aliasesTest.php
index 7365512..06429a8 100755
--- a/geoPHP/tests/tests/aliasesTest.php
+++ b/geoPHP/tests/tests/aliasesTest.php
@@ -1,34 +1,43 @@
 <?php
-require_once('../geoPHP.inc');
-require_once('PHPUnit/Autoload.php');
 
+require_once '../geoPHP.inc';
+require_once 'PHPUnit/Autoload.php';
+/**
+ *
+ */
 class AliasesTests extends PHPUnit_Framework_TestCase {
 
-  function setUp() {
+  /**
+   *
+   */
+  public function setUp() {
 
   }
 
-  function testAliases() {
+  /**
+   *
+   */
+  public function testAliases() {
     foreach (scandir('./input') as $file) {
-      $parts = explode('.',$file);
+      $parts = explode('.', $file);
       if ($parts[0]) {
         $format = $parts[1];
-        $value = file_get_contents('./input/'.$file);
+        $value = file_get_contents('./input/' . $file);
         $geometry = geoPHP::load($value, $format);
 
-        $aliases = array(
-          array('name' => 'getCentroid'),
-          array('name' => 'getArea'),
-          array('name' => 'getX'),
-          array('name' => 'getY'),
-          array('name' => 'getGeos'),
-          array('name' => 'getGeomType'),
-          array('name' => 'getSRID'),
-          array('name' => 'asText'),
-          array('name' => 'asBinary'),
-        );
+        $aliases = [
+          ['name' => 'getCentroid'],
+          ['name' => 'getArea'],
+          ['name' => 'getX'],
+          ['name' => 'getY'],
+          ['name' => 'getGeos'],
+          ['name' => 'getGeomType'],
+          ['name' => 'getSRID'],
+          ['name' => 'asText'],
+          ['name' => 'asBinary'],
+        ];
 
-        foreach($aliases as $alias) {
+        foreach ($aliases as $alias) {
           $argument = NULL;
           $alias_name = $alias['name'];
           if (isset($alias['argument'])) {
@@ -47,6 +56,7 @@ class AliasesTests extends PHPUnit_Framework_TestCase {
                 $this->assertNull($geometry->$alias_name($argument), 'Failed on ' . $alias_name);
               }
               break;
+
             case 'getGeos':
               if ($geometry->geometryType() == 'Point') {
                 $this->assertNotNull($geometry->$alias_name($argument), 'Failed on ' . $alias_name);
@@ -58,6 +68,7 @@ class AliasesTests extends PHPUnit_Framework_TestCase {
                 $this->assertNotNull($geometry->$alias_name($argument), 'Failed on ' . $alias_name);
               }
               break;
+
             case 'getX':
             case 'getY':
               if ($geometry->geometryType() == 'Point') {
@@ -70,6 +81,7 @@ class AliasesTests extends PHPUnit_Framework_TestCase {
                 $this->assertNull($geometry->$alias_name($argument), 'Failed on ' . $alias_name);
               }
               break;
+
             case 'getArea':
               if ($geometry->geometryType() == 'Point') {
                 $this->assertNull($geometry->$alias_name($argument), 'Failed on ' . $alias_name);
@@ -81,6 +93,7 @@ class AliasesTests extends PHPUnit_Framework_TestCase {
                 $this->assertNotNull($geometry->$alias_name($argument), 'Failed on ' . $alias_name);
               }
               break;
+
             case 'getCentroid':
               if ($geometry->geometryType() == 'Point') {
                 $this->assertNotNull($geometry->$alias_name($argument), 'Failed on ' . $alias_name);
@@ -92,11 +105,13 @@ class AliasesTests extends PHPUnit_Framework_TestCase {
                 $this->assertNotNull($geometry->$alias_name($argument), 'Failed on ' . $alias_name);
               }
               break;
+
             case 'asText':
             case 'asBinary':
             case 'getGeomType':
               $this->assertNotNull($geometry->$alias_name($argument), 'Failed on ' . $alias_name);
               break;
+
             default:
               $this->assertTrue($geometry->$alias_name($argument), 'Failed on ' . $alias_name);
           }
diff --git a/geoPHP/tests/tests/geosTest.php b/geoPHP/tests/tests/geosTest.php
index c3e17c1..06fcd3c 100755
--- a/geoPHP/tests/tests/geosTest.php
+++ b/geoPHP/tests/tests/geosTest.php
@@ -1,51 +1,60 @@
 <?php
-require_once('../geoPHP.inc');
-require_once('PHPUnit/Autoload.php');
 
+require_once '../geoPHP.inc';
+require_once 'PHPUnit/Autoload.php';
+/**
+ *
+ */
 class GeosTests extends PHPUnit_Framework_TestCase {
 
-  function setUp() {
+  /**
+   *
+   */
+  public function setUp() {
 
   }
 
-  function testGeos() {
+  /**
+   *
+   */
+  public function testGeos() {
     foreach (scandir('./input') as $file) {
-      $parts = explode('.',$file);
+      $parts = explode('.', $file);
       if ($parts[0]) {
         $format = $parts[1];
-        $value = file_get_contents('./input/'.$file);
+        $value = file_get_contents('./input/' . $file);
         $geometry = geoPHP::load($value, $format);
 
-        $geosMethods = array(
-          array('name' => 'geos'),
-          array('name' => 'setGeos', 'argument' => $geometry->geos()),
-          array('name' => 'PointOnSurface'),
-          array('name' => 'equals', 'argument' => $geometry),
-          array('name' => 'equalsExact', 'argument' => $geometry),
-          array('name' => 'relate', 'argument' => $geometry),
-          array('name' => 'checkValidity'),
-          array('name' => 'isSimple'),
-          array('name' => 'buffer', 'argument' => '10'),
-          array('name' => 'intersection', 'argument' => $geometry),
-          array('name' => 'convexHull'),
-          array('name' => 'difference', 'argument' => $geometry),
-          array('name' => 'symDifference', 'argument' => $geometry),
-          array('name' => 'union', 'argument' => $geometry),
-          array('name' => 'simplify', 'argument' => '0'),
-          array('name' => 'disjoint', 'argument' => $geometry),
-          array('name' => 'touches', 'argument' => $geometry),
-          array('name' => 'intersects', 'argument' => $geometry),
-          array('name' => 'crosses', 'argument' => $geometry),
-          array('name' => 'within', 'argument' => $geometry),
-          array('name' => 'contains', 'argument' => $geometry),
-          array('name' => 'overlaps', 'argument' => $geometry),
-          array('name' => 'covers', 'argument' => $geometry),
-          array('name' => 'coveredBy', 'argument' => $geometry),
-          array('name' => 'distance', 'argument' => $geometry),
-          array('name' => 'hausdorffDistance', 'argument' => $geometry),
-        );
+        $geosMethods = [
+          ['name' => 'geos'],
+          ['name' => 'setGeos', 'argument' => $geometry->geos()],
+          ['name' => 'PointOnSurface'],
+          ['name' => 'equals', 'argument' => $geometry],
+          ['name' => 'equalsExact', 'argument' => $geometry],
+          ['name' => 'relate', 'argument' => $geometry],
+          ['name' => 'checkValidity'],
+          ['name' => 'isSimple'],
+          ['name' => 'buffer', 'argument' => '10'],
+          ['name' => 'intersection', 'argument' => $geometry],
+          ['name' => 'convexHull'],
+          ['name' => 'difference', 'argument' => $geometry],
+          ['name' => 'symDifference', 'argument' => $geometry],
+          ['name' => 'union', 'argument' => $geometry],
+          ['name' => 'simplify', 'argument' => '0'],
+          ['name' => 'disjoint', 'argument' => $geometry],
+          ['name' => 'touches', 'argument' => $geometry],
+          ['name' => 'intersects', 'argument' => $geometry],
+          ['name' => 'crosses', 'argument' => $geometry],
+          ['name' => 'within', 'argument' => $geometry],
+          ['name' => 'contains', 'argument' => $geometry],
+          ['name' => 'overlaps', 'argument' => $geometry],
+          ['name' => 'covers', 'argument' => $geometry],
+          ['name' => 'coveredBy', 'argument' => $geometry],
+          ['name' => 'distance', 'argument' => $geometry],
+          ['name' => 'hausdorffDistance', 'argument' => $geometry],
+        ];
 
-        foreach($geosMethods as $method) {
+        foreach ($geosMethods as $method) {
           $argument = NULL;
           $method_name = $method['name'];
           if (isset($method['argument'])) {
@@ -66,6 +75,7 @@ class GeosTests extends PHPUnit_Framework_TestCase {
                 $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
               }
               break;
+
             default:
               if ($geometry->geometryType() == 'Point') {
                 $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
diff --git a/geoPHP/tests/tests/methodsTest.php b/geoPHP/tests/tests/methodsTest.php
index 9a0f9e3..052a99a 100755
--- a/geoPHP/tests/tests/methodsTest.php
+++ b/geoPHP/tests/tests/methodsTest.php
@@ -1,49 +1,58 @@
 <?php
-require_once('../geoPHP.inc');
-require_once('PHPUnit/Autoload.php');
 
+require_once '../geoPHP.inc';
+require_once 'PHPUnit/Autoload.php';
+/**
+ *
+ */
 class MethodsTests extends PHPUnit_Framework_TestCase {
 
-  function setUp() {
+  /**
+   *
+   */
+  public function setUp() {
 
   }
 
-  function testMethods() {
+  /**
+   *
+   */
+  public function testMethods() {
     foreach (scandir('./input') as $file) {
-      $parts = explode('.',$file);
+      $parts = explode('.', $file);
       if ($parts[0]) {
         $format = $parts[1];
-        $value = file_get_contents('./input/'.$file);
+        $value = file_get_contents('./input/' . $file);
         $geometry = geoPHP::load($value, $format);
 
-        $methods = array(
-          array('name' => 'area'),
-          array('name' => 'boundary'),
-          array('name' => 'getBBox'),
-          array('name' => 'centroid'),
-          array('name' => 'length'),
-          array('name' => 'greatCircleLength'),
-          array('name' => 'haversineLength'),
-          array('name' => 'y'),
-          array('name' => 'x'),
-          array('name' => 'numGeometries'),
-          array('name' => 'geometryN', 'argument' => '1'),
-          array('name' => 'startPoint'),
-          array('name' => 'endPoint'),
-          array('name' => 'isRing'),
-          array('name' => 'isClosed'),
-          array('name' => 'numPoints'),
-          array('name' => 'pointN', 'argument' => '1'),
-          array('name' => 'exteriorRing'),
-          array('name' => 'numInteriorRings'),
-          array('name' => 'interiorRingN', 'argument' => '1'),
-          array('name' => 'dimension'),
-          array('name' => 'geometryType'),
-          array('name' => 'SRID'),
-          array('name' => 'setSRID', 'argument' => '4326'),
-        );
-
-        foreach($methods as $method) {
+        $methods = [
+          ['name' => 'area'],
+          ['name' => 'boundary'],
+          ['name' => 'getBBox'],
+          ['name' => 'centroid'],
+          ['name' => 'length'],
+          ['name' => 'greatCircleLength'],
+          ['name' => 'haversineLength'],
+          ['name' => 'y'],
+          ['name' => 'x'],
+          ['name' => 'numGeometries'],
+          ['name' => 'geometryN', 'argument' => '1'],
+          ['name' => 'startPoint'],
+          ['name' => 'endPoint'],
+          ['name' => 'isRing'],
+          ['name' => 'isClosed'],
+          ['name' => 'numPoints'],
+          ['name' => 'pointN', 'argument' => '1'],
+          ['name' => 'exteriorRing'],
+          ['name' => 'numInteriorRings'],
+          ['name' => 'interiorRingN', 'argument' => '1'],
+          ['name' => 'dimension'],
+          ['name' => 'geometryType'],
+          ['name' => 'SRID'],
+          ['name' => 'setSRID', 'argument' => '4326'],
+        ];
+
+        foreach ($methods as $method) {
           $argument = NULL;
           $method_name = $method['name'];
           if (isset($method['argument'])) {
@@ -58,10 +67,13 @@ class MethodsTests extends PHPUnit_Framework_TestCase {
     }
   }
 
-  function _methods_tester($geometry, $method_name, $argument) {
+  /**
+   *
+   */
+  public function _methods_tester($geometry, $method_name, $argument) {
 
     if (!method_exists($geometry, $method_name)) {
-      $this->fail("Method ".$method_name.'() doesn\'t exists.');
+      $this->fail("Method " . $method_name . '() doesn\'t exists.');
       return;
     }
 
@@ -78,6 +90,7 @@ class MethodsTests extends PHPUnit_Framework_TestCase {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         break;
+
       case 'geometryN':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -89,6 +102,7 @@ class MethodsTests extends PHPUnit_Framework_TestCase {
           $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         break;
+
       case 'startPoint':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -97,10 +111,11 @@ class MethodsTests extends PHPUnit_Framework_TestCase {
           $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         if ($geometry->geometryType() == 'MultiLineString') {
-          //TODO: Add a method startPoint() to MultiLineString.
-          //$this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
+          // TODO: Add a method startPoint() to MultiLineString.
+          // $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);.
         }
         break;
+
       case 'endPoint':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -109,10 +124,11 @@ class MethodsTests extends PHPUnit_Framework_TestCase {
           $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         if ($geometry->geometryType() == 'MultiLineString') {
-          //TODO: Add a method endPoint() to MultiLineString.
-          //$this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
+          // TODO: Add a method endPoint() to MultiLineString.
+          // $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);.
         }
         break;
+
       case 'isRing':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -124,6 +140,7 @@ class MethodsTests extends PHPUnit_Framework_TestCase {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         break;
+
       case 'isClosed':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -135,6 +152,7 @@ class MethodsTests extends PHPUnit_Framework_TestCase {
           $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         break;
+
       case 'pointN':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -143,10 +161,11 @@ class MethodsTests extends PHPUnit_Framework_TestCase {
           $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         if ($geometry->geometryType() == 'MultiLineString') {
-          //TODO: Add a method pointN() to MultiLineString.
-          //$this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
+          // TODO: Add a method pointN() to MultiLineString.
+          // $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);.
         }
         break;
+
       case 'exteriorRing':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -158,6 +177,7 @@ class MethodsTests extends PHPUnit_Framework_TestCase {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         break;
+
       case 'numInteriorRings':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -169,6 +189,7 @@ class MethodsTests extends PHPUnit_Framework_TestCase {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         break;
+
       case 'interiorRingN':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -180,6 +201,7 @@ class MethodsTests extends PHPUnit_Framework_TestCase {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         break;
+
       case 'SRID':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -191,6 +213,7 @@ class MethodsTests extends PHPUnit_Framework_TestCase {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         break;
+
       case 'getBBox':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -202,6 +225,7 @@ class MethodsTests extends PHPUnit_Framework_TestCase {
           $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         break;
+
       case 'centroid':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -213,6 +237,7 @@ class MethodsTests extends PHPUnit_Framework_TestCase {
           $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         break;
+
       case 'length':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -224,6 +249,7 @@ class MethodsTests extends PHPUnit_Framework_TestCase {
           $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         break;
+
       case 'numGeometries':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -235,6 +261,7 @@ class MethodsTests extends PHPUnit_Framework_TestCase {
           $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         break;
+
       case 'numPoints':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -246,6 +273,7 @@ class MethodsTests extends PHPUnit_Framework_TestCase {
           $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         break;
+
       case 'dimension':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -257,6 +285,7 @@ class MethodsTests extends PHPUnit_Framework_TestCase {
           $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         break;
+
       case 'boundary':
         if ($geometry->geometryType() == 'Point') {
           $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
@@ -268,33 +297,44 @@ class MethodsTests extends PHPUnit_Framework_TestCase {
           $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         }
         break;
+
       case 'haversineLength':
-        //TODO: Check if output is a float >= 0.
-        //TODO: Sometimes haversineLength() returns NAN, needs to check why.
+        // TODO: Check if output is a float >= 0.
+        // TODO: Sometimes haversineLength() returns NAN, needs to check why.
         break;
+
       case 'greatCircleLength':
       case 'area':
         $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         break;
+
       case 'geometryType':
         $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
         break;
+
       case 'setSRID':
-        //TODO: The method setSRID() should return TRUE.
+        // TODO: The method setSRID() should return TRUE.
         break;
+
       default:
         $this->assertTrue($geometry->$method_name($argument), 'Failed on ' . $method_name);
     }
 
   }
 
-  function _methods_tester_with_geos($geometry) {
-    // Cannot test methods if GEOS is not intstalled
-    if (!geoPHP::geosInstalled()) return;
+  /**
+   *
+   */
+  public function _methods_tester_with_geos($geometry) {
+    // Cannot test methods if GEOS is not intstalled.
+    if (!geoPHP::geosInstalled()) {
+      return;
+    }
 
-    $methods = array(
-      //'boundary', //@@TODO: Uncomment this and fix errors
-      'envelope',   //@@TODO: Testing reveales errors in this method -- POINT vs. POLYGON
+    $methods = [
+      // 'boundary', //@@TODO: Uncomment this and fix errors
+    // @@TODO: Testing reveales errors in this method -- POINT vs. POLYGON
+      'envelope',
       'getBBox',
       'x',
       'y',
@@ -303,42 +343,42 @@ class MethodsTests extends PHPUnit_Framework_TestCase {
       'isRing',
       'isClosed',
       'numPoints',
-    );
+    ];
 
     foreach ($methods as $method) {
-      // Turn GEOS on
+      // Turn GEOS on.
       geoPHP::geosInstalled(TRUE);
       $geos_result = $geometry->$method();
 
-      // Turn GEOS off
+      // Turn GEOS off.
       geoPHP::geosInstalled(FALSE);
       $norm_result = $geometry->$method();
 
-      // Turn GEOS back On
+      // Turn GEOS back On.
       geoPHP::geosInstalled(TRUE);
 
       $geos_type = gettype($geos_result);
       $norm_type = gettype($norm_result);
 
       if ($geos_type != $norm_type) {
-        $this->fail('Type mismatch on '.$method);
+        $this->fail('Type mismatch on ' . $method);
         $this->dump($geos_type);
         $this->dump($norm_type);
         continue;
       }
 
-      // Now check base on type
+      // Now check base on type.
       if ($geos_type == 'object') {
-        $haus_dist = $geos_result->hausdorffDistance(geoPHP::load($norm_result->out('wkt'),'wkt'));
+        $haus_dist = $geos_result->hausdorffDistance(geoPHP::load($norm_result->out('wkt'), 'wkt'));
 
         // Get the length of the diagonal of the bbox - this is used to scale the haustorff distance
-        // Using Pythagorean theorem
+        // Using Pythagorean theorem.
         $bb = $geos_result->getBBox();
-        $scale = sqrt((($bb['maxy'] - $bb['miny'])^2) + (($bb['maxx'] - $bb['minx'])^2));
+        $scale = sqrt((($bb['maxy'] - $bb['miny']) ^ 2) + (($bb['maxx'] - $bb['minx']) ^ 2));
 
-        // The difference in the output of GEOS and native-PHP methods should be less than 0.5 scaled haustorff units
+        // The difference in the output of GEOS and native-PHP methods should be less than 0.5 scaled haustorff units.
         if ($haus_dist / $scale > 0.5) {
-          $this->fail('Output mismatch on '.$method);
+          $this->fail('Output mismatch on ' . $method);
           $this->dump('GEOS : ');
           $this->dump($geos_result->out('wkt'));
           $this->dump('NORM : ');
@@ -349,7 +389,7 @@ class MethodsTests extends PHPUnit_Framework_TestCase {
 
       if ($geos_type == 'boolean' || $geos_type == 'string') {
         if ($geos_result !== $norm_result) {
-          $this->fail('Output mismatch on '.$method);
+          $this->fail('Output mismatch on ' . $method);
           $this->dump('GEOS : ');
           $this->dump((string) $geos_result);
           $this->dump('NORM : ');
@@ -358,8 +398,9 @@ class MethodsTests extends PHPUnit_Framework_TestCase {
         }
       }
 
-      //@@TODO: Run tests for output of types arrays and float
-      //@@TODO: centroid function is non-compliant for collections and strings
+      // @@TODO: Run tests for output of types arrays and float
+      // @@TODO: centroid function is non-compliant for collections and strings
     }
   }
+
 }
diff --git a/geoPHP/tests/tests/placeholdersTest.php b/geoPHP/tests/tests/placeholdersTest.php
index 31baf95..bebb357 100755
--- a/geoPHP/tests/tests/placeholdersTest.php
+++ b/geoPHP/tests/tests/placeholdersTest.php
@@ -1,32 +1,41 @@
 <?php
-require_once('../geoPHP.inc');
-require_once('PHPUnit/Autoload.php');
 
+require_once '../geoPHP.inc';
+require_once 'PHPUnit/Autoload.php';
+/**
+ *
+ */
 class PlaceholdersTests extends PHPUnit_Framework_TestCase {
 
-  function setUp() {
+  /**
+   *
+   */
+  public function setUp() {
 
   }
 
-  function testPlaceholders() {
+  /**
+   *
+   */
+  public function testPlaceholders() {
     foreach (scandir('./input') as $file) {
-      $parts = explode('.',$file);
+      $parts = explode('.', $file);
       if ($parts[0]) {
         $format = $parts[1];
-        $value = file_get_contents('./input/'.$file);
+        $value = file_get_contents('./input/' . $file);
         $geometry = geoPHP::load($value, $format);
 
-        $placeholders = array(
-          array('name' => 'hasZ'),
-          array('name' => 'is3D'),
-          array('name' => 'isMeasured'),
-          array('name' => 'isEmpty'),
-          array('name' => 'coordinateDimension'),
-          array('name' => 'z'),
-          array('name' => 'm'),
-        );
+        $placeholders = [
+          ['name' => 'hasZ'],
+          ['name' => 'is3D'],
+          ['name' => 'isMeasured'],
+          ['name' => 'isEmpty'],
+          ['name' => 'coordinateDimension'],
+          ['name' => 'z'],
+          ['name' => 'm'],
+        ];
 
-        foreach($placeholders as $method) {
+        foreach ($placeholders as $method) {
           $argument = NULL;
           $method_name = $method['name'];
           if (isset($method['argument'])) {
@@ -46,6 +55,7 @@ class PlaceholdersTests extends PHPUnit_Framework_TestCase {
                 $this->assertNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
               }
               break;
+
             case 'coordinateDimension':
             case 'isEmpty':
             case 'isMeasured':
@@ -61,6 +71,7 @@ class PlaceholdersTests extends PHPUnit_Framework_TestCase {
                 $this->assertNotNull($geometry->$method_name($argument), 'Failed on ' . $method_name);
               }
               break;
+
             default:
               $this->assertTrue($geometry->$method_name($argument), 'Failed on ' . $method_name);
           }
@@ -70,4 +81,5 @@ class PlaceholdersTests extends PHPUnit_Framework_TestCase {
     }
 
   }
+
 }
diff --git a/src/GeoPHPInterface.php b/src/GeoPHPInterface.php
index 2f9aacb..cb2ad0d 100644
--- a/src/GeoPHPInterface.php
+++ b/src/GeoPHPInterface.php
@@ -1,9 +1,12 @@
 <?php
 
-
 namespace Drupal\geophp;
 
+/**
+ *
+ */
 interface GeoPHPInterface {
+
   /**
    * Retrieves the GeoPHP library current version.
    *
diff --git a/src/GeoPHPWrapper.php b/src/GeoPHPWrapper.php
index 2c708e0..73669e8 100644
--- a/src/GeoPHPWrapper.php
+++ b/src/GeoPHPWrapper.php
@@ -2,11 +2,16 @@
 
 namespace Drupal\geophp;
 
+/**
+ *
+ */
 class GeoPHPWrapper implements GeoPHPInterface {
 
-
-  function __construct() {
-    require_once(drupal_get_path('module', 'geophp') . '/geoPHP/geoPHP.inc');
+  /**
+   *
+   */
+  public function __construct() {
+    require_once drupal_get_path('module', 'geophp') . '/geoPHP/geoPHP.inc';
   }
 
   /**
@@ -20,14 +25,14 @@ class GeoPHPWrapper implements GeoPHPInterface {
    * {@inheritdoc}
    */
   public function load() {
-    return call_user_func_array(array('\geoPHP', 'load'), func_get_args());
+    return call_user_func_array(['\geoPHP', 'load'], func_get_args());
   }
 
   /**
    * {@inheritdoc}
    */
   public function getAdapterMap() {
-    return call_user_func_array(array('\geoPHP', 'getAdapterMap'), func_get_args());
+    return call_user_func_array(['\geoPHP', 'getAdapterMap'], func_get_args());
   }
 
 }
